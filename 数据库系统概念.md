[[Mysql]]

## 第一章
### 四个基本概念
- 数据：Data
- 数据库：DataBase
- 数据库管理系统：DBMS
	- 数据库管理系统的功能
		1. 数据定义功能
		2. 数据存储、组织、管理功能
		3. 数据操纵功能
		4. 数据库的事务管理和运行管理
		5. 数据库的建立和维护功能
		6. 其他
- 数据库系统：DBS
- 数据库系统的组成
	1. 数据库
	2. 数据库管理系统
	3. 应用程序
	4. 数据库管理员
### 发展阶段
- 人工存储阶段
- 文件系统阶段
	- 数据管理者：文件系统，所有数据在操作系统中
	- 特点：数据共享差、冗余度大、数据独立性差（存储行为仅仅为了某个应用）
- 数据库阶段
	- 特点：
		1. 数据结构化
		2. 数据共享性高、冗余度低且易扩充
		3. 数据独立性高：包括逻辑独立性和物理独立性，主要由数据库管理系统提供的二级映像来保证
		4. 数据由DBMS统一管理
			-  DBMS数据控制功能
				1. 数据的安全性保护
				2. 数据的完整性检查
				3. 并发控制
				4. 数据库恢复 
### 数据模型
- 数据模型是对世界数据特征的抽象，是数据库系统的核心和基础
- 数据模型的组成要素：
	1. 数据结构
	2. 数据操作
	3. 数据的完整性约束
- 数据模型分为概念模型以及逻辑和物理模型
- 概念模型
	- E-R图
		![[e-r图.PNG]]
- 逻辑模型和物理模型
	- 层次模型（树）
		![[层次模型.PNG]]
	- 网状模型（数据结构中的图）
	- *==关系模型==* （表）
		- 关系：一个关系通常来说是一张表
		- 元组：表中的一行
		- 属性：表中的一列
		- 码：可以唯一确定一个元组
			- 比如，学号可以确定学生
			- 学号和课程，可以确定成绩
		- 域：是属性的取值范围（驾照的年龄设置为18-60）
		- 分量：元组的一个属性值
		- 关系模式：是对关系的描述，比如：学生（学号，姓名，年龄）
		- 关系模型的最基本要求：
			[[关系模型最基本要求]]
		- 关系模型的完整性约束：
			1. 实体完整性
				- 主码唯一且非空
			2. 参照完整性
				- 外码要么为空，要么在另一个表中的主码
			3. 用户定义完整性
				- 自定定义的，比如，年龄在12-30岁之间
	- 面向对象数据模型
	- 对象关系模型
	- 半结构化数据模型
### 三级模式两级映像
![[三级模式两级映像.PNG]]

- 外模式——也称子模式或用户模式
	- 一个数据库有多个外模式
- 模式——逻辑模型
	- 一个数据库只有一个模式
- 内模式——存储模式
	- 只有一个
- 数据独立性
	- 物理独立性——当内模式结构改变时，只要修改内模式、模式映像即可保持物理独立性
	- 逻辑独立性——当模式结构改变的时候，只要修改外模式/模式映像即可保持逻辑独立性
### 数据库系统的组成
1. 硬件平台及数据库
2. 软件
3. 人员：包括数据库管理员、系统分析员和数据库设计人员

## 第二章关系数据库
### 关系模式
[[关系模式]]
### 关系操作
- 插入、查询、删除、修改
- 查询操作最重要，可以分为：选择、投影、连接、除、并、差、交、笛卡尔积
- 最基本五个：选择、投影、并、差、笛卡尔积
### 关系语言分类
- 关系代数语言
	[[关系代数语言]]
- 关系演算语言（了解）
	- 具有关系代数关系演算功能的SQL语言
### 关系的完整性
- 实体完整性：表中不能有表
- 参照完整性：外码要么为空，要么对应被参照表的主码
- 用户定义的完整性：非空、唯一等等
## 第三章 SQL

### SQL特点
### SQL的基本概念
### SQL的基本语法

1. 综合统一：把定义、修改、安全性、完整性、事务控制、动态sql等统一起来
2. 高度非过程化：层次网状模型是过程化的，关系模型是非过程化的
3. 面向集合的操作方式
4. 以同一种语法结构提供多种使用方式
SQL的功能——create、drop、alter
#### 数据定义

| 操作对象 | 创建            | 删除          | 修改          |
| ---- | ------------- | ----------- | ----------- |
| 模式   | create schema | drop schema |             |
| 表    | create table  | drop table  | alter index |
| 视图   | create view   | drop view   |             |
| 索引   | create index  | drop index  | alter index |

-  模式定义和删除：
	一个关系数据库管理系统DBMS的实例(instance)中可以建立多个数据库，一个数据
	库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。
	- 定义模式：
	`[例3.1] 为用户WANG 定义一个学生-课程模式S-T.`
	`CREATE SCHEMA "S-T" AUTHORIZATION WANG;`
	- 删除模式：
	`DROP SCHEMA<模式名><CASCADE|RESTRICT>;`
	CASCADE 表示级联，把模式下的表和视图全部删除
	RESTRICT 表示限制，如果模式下有表和视图，则停止执行该语句
- 基本表定义、删除、修改
	- 修改表
		`[例3.8]向Student表增加“入学时间”列，其数据类型为日期型。`
		ALTER TABLE Student ADD S_entrance DATE;
		`[例3.9]将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。`
		ALTER TABLE Student ALTER COLUMN Sage INT;
		`[例3.10]增加课程名称必须取唯一值的约束条件。`
		ALTER TABLE Course ADD UNIQUE(Cname);
	- 删除表
		`DROP TABLE<表名>[RESTRICT|CASCADE];`
		若选择RESTRICT，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用（如CHECK，FOREIGN KEY等约束），不能有视图，不能有触发器(trigger)，不能存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。
		若选择CASCADE，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。
		DROP TABLE Student CASCADE;
	`[例3.5] 建立一个“学生”表Student.`
```sql
	CREATE TABLE Student
	(Sno CHAR(9) PRIMARY KEY,	设置为主码
	Sname CHAR(20) UNIQUE,	不允许重复
	Ssex CHAR(2),
	Sage SMALLINT,
	Sdept CHAR(20)
	);
	
	CREATE TABLE Course
	(Cno CHAR(4) PRIMARY KEY,	/*列级完整性约束条件，Cno是主码*/
	Cname CHAR(40) NOT NULL,	/*列级完整性约束条件，Cname不能取空值*/
	Cpno CHAR(4),	/* Cpno的含义是先修课*/
	Ceredit SMALLINT,
	FOREIGN KEY (Cpno) REFERENCES Course(Cno)
	/*表级完整性约束条件，Cpo是外码，被参照表是Course，被参照列是Cno*/
	);
	```

| 数据类型                 | 含义                                |
| -------------------- | --------------------------------- |
| CHAR(n),CHARACTER(n) | 长度为n的定长字符串                        |
| VARCHAR(N)           | 最大长度为n的变长字符串                      |
| CLOB                 | 字符串大对象                            |
| BLOB                 | 二进制大对象                            |
| INT，INTEGER          | 长整数(4字节)                          |
| SMALLINT             | 短整数(2字节)                          |
| BIGINT               | 大整数(8字节)                          |
| NUMBERIC(p,d)        | 定点数，由p位数字(不包括符号、小数点)组成，小数点后面有d位数字 |
- 索引的建立和删除
	索引名
	CREATE UNIQUE INDEX Stusno ON Student(Sno);
	CREATE UNIQUE INDEX Coucno ON Course(Cno);
	CREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC);
	`[例3.14] 将SC表的SCno索引名改为SCSno.`
	ALTER INDEX SCno RENAME TO SCSno;
	`[例3.15] 删除Student表的Stusname索引。`
	DROP INDEX Stusname:
####  数据查询：SELECT
- 基本的查询、带通配符\*查询、带表达式（2014-age）查询、列重命名查询、字符变小写查询、去重查询
	`SELECT Sname, Sno, Sdept	FROM Student;`
	`[例3.18]  查询全体学生的详细记录。`
```sql
SELECT * FROM Student;
SELECT Sname,2014-Sage	FROM Student;/*查询结果的第2列是一个算术表达式*/
```

| Sname	<br> | 2014-Sage |
| ---------- | --------- |
| 李勇	<br>    | 1994      |
| 刘晨	<br>    | 1995      |
| 王敏	<br>    | 1996      |
| 张立         | 1995      |

Student

| 学号Sno     | 姓名Sname | 性别Ssex | 年龄Sage | 所在系Sdept |
| --------- | ------- | ------ | ------ | -------- |
| 201215121 | 李勇      | 男      | 20     | cs       |
| 201215122 | 刘晨      | 女      | 19     | cs       |
| 201215123 | 王敏      | 女      | 18     | MA       |
| 201215125 | 张立      | 男      | 19     | IS       |
给查询的列进行重命名
```sql
SELECT Sname NAME,"Year of Birth:" BIRTH,2014-Sage BIRTHDAY,LOWER(Sdept),DEPARTMENT FROM Student;
```

| NAME | BIRTH          | BIRTHDAY | DEPARTMENT |
| ---- | -------------- | -------- | ---------- |
| 李勇   | Year of Birth: | 1994     | cs         |
| 刘晨   | Year of Birth: | 1995     | cs         |
| 王敏   | Year of Birth: | 1996     | ma         |
| 张立   | Year of Birth: | 1995     | is         |
去掉重复值
`SELECT DISTINCT Sno FROM SC;`

|Sno|
|----|
|201215121|
|201215122|
- 
	- 条件查询（简单条件、like模糊匹配字符、转义后匹配、多条件查询）：

|查询条件|	谓词|
|----------|-------|
|比较|          =,>,<,>=,<=,!=,<>,!>,!<|
|确定范围|	BETWEEN AND, NOT BETWEEN AND|
|确定集合|	IN, NOT IN|
|字符匹配|	LIKE, NOT LIKE|
|空值|	IS NULL, IS NOT NULL|
|多重条件（逻辑运算）|	AND, OR, NOT|
`[例3.22]查询计算机科学系全体学生的名单。	`
SELECT Sname FROM Student WHERE Sdept='CS';
`[例3.23] 查询所有年龄在20岁以下的学生姓名及其年龄。`
SELECT Sname, Sage
FROM Student
WHERE Sage<20;
`[例3.27] 查询计算机科学系(CS)、数学系(MA)和信息系(IS)学生的姓名和性别。`
SELECT Sname, Ssex
FROM Student
WHERE Sdept IN('CS','MA','IS');
- Like模糊匹配
	%（百分号）代表任意长度（长度可以为0）的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串，如acb、addgb、ab等都满足该匹配串。
	_ (下横线）代表任意单个字符。
	例如a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb、afb等都满足该匹配串
	
`[例3.30] 查询所有姓刘的学生的姓名、学号和性别。`
SELECT Sname, Sno, Ssex 
FROM Student 
WHERE Sname LIKE '刘S';// 刘123 
`[例3.31]  查询姓“欧阳”且全名为三个汉字的学生的姓名。`
SELECT Sname 
FROM Student 
WHERE Sname LIKE'欧阳_';

`[例3.33]  查询所有不姓刘的学生的姓名、学号和性别。`
SELECT Sname, Sno, Ssex
FROM Student
WHERE Sname NOT LIKE'刘%‘；
`当我需要匹配的字符里面有 下划线，就需要进行转义字符`
`[例3.34] 查询DB Design课程的课程号和学分。`
SELECT Cno, Ccredit 
FROM Course 
WHERE Cname LIKE 'DB\\\_Design' ESCAPE'\\';
- 涉及空值
SELECT Sno, Cno              SELECT Sno, Cno
FROM SC                            FROM   SC
WHERE Grade IS NULL;
/\*分数 Grade是空值\*/        WHERE Grade IS NOT NULL;
- 排序查询结果

按照成绩进行降序排序                  按照成绩进行升序排序
SELECT Sno, Grade                      SELECT Sno, Grade
FROM SC                                       FROM SC
WHERE Cno='3'                             WHERE Cno='3'
ORDER BY Grade DESC;               ORDER BY Grade

SELECT\*                 查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。
FROM Student
ORDER BY Sdept,Sage DESC;          第一关键字Sdept 第二关键字Sage
- 聚合函数
聚合函数

| COUNT（\*）                     | 统计元组个数              |
| ----------------------------- | ------------------- |
| COUNT(\[DISTINCT \| ALL]<列名>) | 统计一列中值的个数           |
| SUM(\[DISTINCT   \| ALL]<列名>) | 计算一列值的总和（此列必须是数值型）  |
| AVG(\[DISTINCT   \| ALL]<列名>) | 计算一列值的平均值（此列必须是数值型） |
| MAX(\[DISTINCT   \| ALL]<列名>) | 求一列值中的最大值           |
| MIN(\[DISTINCT  \| ALL]<列名>)  | 求一列值中的最小值           |

`[例3.41]  查询学生总人数。`                       `[例3.42]  查询选修了课程的学生人数。`
SELECT COUNT（\*）                                    SELECT COUNT(DISTINCT Sno)
FROM Student;                                                  FROM SC;
`[例3.43]  计算选修1号课程的学生平均成绩。`
SELECT AVG(Grade)               SELECT MAX(Grade)
FROM SC                                     FROM SC
WHERE Cno='1';                      WHERE Cno='1';

`[例3.45] 查询学生201215012选修课程的总学分数。`
SELECT SUM(Ccredit)
FROM SC, Course
WHERE Sno='201215012' AND SC.Cno= Course.Cno;
当聚集函数遇到空值时，除COUNT（\*）外，都跳过空值而只处理非空值。
group by聚合函数，进行分类汇总
`[例3.46]  求各个课程号及相应的选课人数。`
SELECT Cno,COUNT(Sno)
FROM SC
GROUP BY Cno;

| Cno | COUNT(Sno) |
| --- | ---------- |
| 1   | 22         |
| 2   | 34         |
| 3   | 44         |
| 4   | 33         |
| 5   | 48         |

select Cno, Count(Sno)	
from sc	
group by Cno	
having Count(Sno)>35	

| Cno | COUNT(Sno) |
| --- | ---------- |
| 3   | 44         |
| 5   | 48         |
Having对group by的筛选
6. 多表连接
SELECT * FROM A,B 实际上进行的是笛卡尔积运算
A表

|学号|	姓名|	班级|
|-----|------|--|
|1|	张三|	一班|
|2|	李四|	二班|
|3|	王五|	二班|
B

| 学号  | 课程  | 成绩  |
| --- | --- | --- |
| 1   | 语文  | 99  |
| 1   | 数学  | 88  |
| 2   | 英语  | 70  |
| 3   | 物理  | 77  |
| 3   | 化学  | 99  |

| A.学号 | 姓名  | 班级  | B.学号 | 课程  | 成绩  |
| ---- | --- | --- | ---- | --- | --- |
| 1    | 张三  | 一班  | 1    | 语文  | 99  |
| 1    | 张三  | 一班  | 1    | 数学  | 88  |
| 1    | 张三  | 一班  | 2    | 英语  | 70  |
| 1    | 张三  | 一班  | 3    | 物理  | 77  |
| 1    | 张三  | 一班  | 3    | 化学  | 99  |
| 2    | 李四  | 二班  | 1    | 语文  | 99  |
| 2    | 李四  | 二班  | 1    | 数学  | 88  |
| 2    | 李四  | 二班  | 2    | 英语  | 70  |
| 2    | 李四  | 二班  | 3    | 物理  | 77  |
| 2    | 李四  | 二班  | 3    | 化学  | 99  |
| 3    | 王五  | 二班  | 1    | 语文  | 99  |
| 3    | 王五  | 二班  | 1    | 数学  | 88  |
| 3    | 王五  | 二班  | 2    | 英语  | 70  |
| 3    | 王五  | 二班  | 3    | 物理  | 77  |
| 3    | 王五  | 二班  | 3    | 化学  | 99  |
有意义的是等值连接
```sql
select* from
A,B
where A.学号=B.学号
```

| A.学号 | 姓名  | 班级  | B.学号 | 课程  | 成绩  |
| ---- | --- | --- | ---- | --- | --- |
| 1    | 张三  | 一班  | 1    | 语文  | 99  |
| 1    | 张三  | 一班  | 1    | 数学  | 88  |
| 2    | 李四  | 二班  | 2    | 英语  | 70  |
| 3    | 王五  | 二班  | 3    | 物理  | 77  |
| 3    | 王五  | 二班  | 3    | 化学  | 99  |
```sql
Select A.学号，班级，课程，成绩
from A,B
where A.学号=B.学号
```

| 学号  | 姓名  | 班级  | 课程  | 成绩  |
| --- | --- | --- | --- | --- |
| 1   | 张三  | 一班  | 语文  | 99  |
| 1   | 张三  | 一班  | 数学  | 88  |
| 2   | 李四  | 二班  | 英语  | 70  |
| 3   | 王五  | 二班  | 物理  | 77  |
| 3   | 王五  | 二班  | 化学  | 99  |

```sql
select A.学号，班级，课程，成绩
from A,B
where A.学号=B.学号and成绩>80
```

| 学号  | 姓名  | 班级  | 课程  | 成绩  |
| --- | --- | --- | --- | --- |
| 1   | 张三  | 一班  | 语文  | 99  |
| 1   | 张三  | 一班  | 数学  | 88  |
| 3   | 王五  | 二班  | 化学  | 99  |
左外连接
```sql
SELECT Student. Sno, Sname, Ssex, Sage, Sdept, Cno, Grade
FROM Student LEFT OUTER JOIN SC ON (Student. Sno=SC. Sno);
```
7. 嵌套查询

| 学号Sno     | 姓名Sname | 性别Ssex | 年龄Sage | 所在系Sdept |
| --------- | ------- | ------ | ------ | -------- |
| 201215121 | 李勇      | 男      | 20     | cs       |
| 201215122 | 刘晨      | 女      | 19     | cs       |
| 201215123 | 王敏      | 女      | 18     | MA       |
| 201215125 | 张立      | 男      | 19     | IS       |
sc

| 学号Sno     | 课程号Cno | 成绩Grade |
| --------- | ------ | ------- |
| 201215121 | 1      | 92      |
| 201215121 | 2      | 85      |
| 201215121 | 3      | 88      |
| 201215122 | 2      | 90      |
| 201215122 | 3      | 80      |

选择2号课程的学生姓名
```sql
SELECT Sname                /*外层查询或父查询*/
FROM Student
WHERE Sno IN
(SELECT Sno               /*内层查询或子查询*/选择2号课程的学生
FROM SC
WHERE Cno='2');
```

| 学号Sno     |
| --------- |
| 201215121 |
| 201215122 |

| 姓名Sname |
| ------- |
| 李勇      |
| 刘磊      |
8. 存在谓词

查询选修了全部课程的学生姓名
```sql
SELECT Sname	        /*查询一个学生的学号（在Student表中循环取学生信息）*/
FROM Student
WHERE NOT EXISTS(        /*不存在课程（在Course中循环取所有课程信息）*/
SELECT*
FROM Course
WHERE NOT EXISTS(           /*没选修（在SC表中循环比对）*/
SELECT*
FROM SC
WHERE SC.Sno= Student.Sno AND SC.Cno= Course.Cno
)
);
```

9. 集合查询

差集
```sql
SELECT*
FROM Student
WHERE Sdept='CS'
EXCEPT
SELECT*
FROM Student
WHERE Sage<=19;
```
并集
```sql
SELECT *
FROM Student
WHERE Sdept='CS'
UNION
SELECT*
FROM Student
WHERE Sage<=19;
```
交集
```sql
SELECT*
FROM Student
WHERE Sdept='CS'
INTERSECT
SELECT*
FROM Student
WHERESage<=19;
```

#### 数据操纵：insert update delete
数据插入
```sql
INSERT   
INTO Student (Sno, Sname, Ssex, Sdept, Sage) 
VALUES ('201215128','陈冬‘,‘男','IS', 18);
```
```sql
INSERT
INTO Student
VALUES ('201215126','张成民‘，‘男‘,'18','CS');
```
[例3.71] 插入一条选课记录('201215128','1')
```sql
INSERT
INTO SC(Sno, Cno)
VALUES('201215128','1');
```
```sql
INSERT
INTO Dept_age(Sdept, Avg_age) \可以把 select查询的结果插入表
SELECT Sdept,AVG(Sage)
FROM Student
GROUP BY Sdept;
```
修改语句
1.修改某一个元组的值
[例3.73] 将学生201215121的年龄改为22岁。	
```sql
UPDATE Student	
SET Sage=22	
WHERE Sno='201215121';
```

[例3.74]  将所有学生的年龄增加1岁。
```sql
UPDATE Student
SET Sage=Sage+1;
```

删除
[例3.76] 删除学号为201215128的学生记录。
```sql
DELETE
FROM Student
WHERE Sno='201215128';
```
#### 数据控制：grant revoke

下一章

#### 额外补充
- 视图
	是一个虚表，是从一个表或者多个表或者另一个视图导出来的表，视图不是一个真正的表，他的数据都是在基本表中，所以视图的更新最终要转换到基本表中，但并不是所有的视图都是可更新的（例如分类汇总的视图）。
	保留了主码的视图叫做行列子集视图，这类视图一定是可以更新


- 创建视图
```sql
	CREATE VIEW<视图名> [（<列名>[，<列名>]…）]
	AS <子查询>
	[WITH CHECK OPTION];
```


为防止用户通过视图对数据进行增加、删除、修改时，有意无意地对不属于视图范围内的基本表数据进行操作，可在定义视图时加上WITH CHECK OPTION子句。这样在视图上增、删、改数据时，关系数据库管理系统会检查视图定义中的条件，若不满足条件则拒绝执行该操作。
```sql
CREATE VIEW IS_Student
AS
SELECT Sno, Sname, Sage
FROM Student
WHERE Sdept='IS'	/*IS这个科系的学生*/
WITH CHECK OPTION;
```
若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码则称这类视图为行列子集视图。

- 删除视图
`DROP VIEW<视图名>[CASCADE];`
视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其他视图，则使用CASCADE级联删除语句把该视图和由它导出的所有视图一起删除。

- 视图的作用：
	1. 可以简化操作
	2. 可以用不同角度看待同一数据
	3. 提供一定程度的逻辑独立性
	4. 能够提供安全性保护
	5. 适当利用视图可以更清晰表达查询
- 派生表与视图
```sql
SELECT *
FROM (SELECT Sno,AVG(Grade)	/*子查询生成一个派生表S_G∗/
        FROM SC
        GROUP BY Sno) AS S_G(Sno,Gavg)
WHERE Gavg>=90;
```
但定义视图并查询视图与基于派生表的查询是有区别的。视图一旦定义，其定义将水久保存在数据字典中，之后的所有查询都可以直接引用该视图。而派生表只是在语句执行时临时定义，语句执行后该定义即被删除。

### 第四章 数据库安全性
### 数据库安全性概述
#### 一.不安全因素：
1. 非授权对数据库的恶意存取和破坏
2. 数据库中重要的数据泄露
3. 安全环境的脆弱

#### 二.数据安全性控制
1. 用户身份鉴别：
	- 静态口令鉴别
	- 动态口令鉴别
	- 生物特征鉴别
	- 智能卡鉴别
2. 存取控制：
3. 自主存取控制方法
4. 授权：授权与回收
（1）授权：grant
grant
5. GRANT
GRANT语句的一般格式为
```sql
GRANT<权限>[,<权限>]…
ON<对象类型><对象名>[,<对象类型><对象名>]…
TO<用户>[,<用户>]…
[WITH GRANT OPTION];
```
[例4.1] 把查询Student表的权限授给用户U1.
```sql
GRANT SELECT
ON TABLE Student
TO U1;
```
[例4.2] 把对Student表和Course表的全部操作权限授予用户U2和U3.
```sql
GRANT ALL PRIVILEGES ON TABLE Student, Course TO U2,U3;
```
### 数据库安全性控制
### 视图机制
### 审计
### 数据加密





