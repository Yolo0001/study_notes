# 算法训练营

## 01数据结构与算法总览

· 数据结构脑图

![](D:\LearninginUniversity\2022——自学\笔记\img\数据结构.png)

· 算法脑图

![](D:\LearninginUniversity\2022——自学\笔记\img\算法.png)

### 课后作业

绘制自己的数据结构和算法脑图
用脑图的方式把知识的脉络串联起来，不管对于学习新知识还是巩固已有知识，都是一种很好的学习方式。同学们可以将目前自己所掌握的数据结构和算法知识绘制成脑图，在绘制过程中可以查阅资料，补充目前掌握欠缺的部分，找到自己薄弱的地方。后面再通过课程的学习和刻意练习，动态地将自己绘制的脑图逐步补充、完善，从而达到真正的融会贯通。



## 02训练准备与复杂度分析

### 参考链接

· [Windows Microsoft New Terminal](http://github.com/microsoft/terminal)

· [VS Code Themes](http://vscodethemes.com/)

· [教你打造一款颜值逆天的 VS Code](http://juejin.im/entry/587e0f2f570c352201113e14)

· [炫酷的 VS Code 毛玻璃效果](http://juejin.im/post/5ce1365151882525ff28ed47)

· [自顶向下的编程方式](http://markhneedham.com/blog/2008/09/15/clean-code-book-review/)

· [自顶向下编程的 LeetCode 例题](http://leetcode-cn.com/problems/valid-palindrome/)

### 参考链接

· [如何理解算法时间复杂度的表示法](http://www.zhihu.com/question/21387264)

· [Master theorem](http://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms))

· [主定理](http://zh.wikipedia.org/wiki/主定理)

## 03数组、链表、跳表

### 参考链接

· [Java 源码分析（ArrayList）](http://developer.classpath.org/doc/java/util/ArrayList-source.html)

· [Linked List 的标准实现代码](http://www.geeksforgeeks.org/implementing-a-linked-list-in-java-using-class/)

· [Linked List 示例代码](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked Lists/code/LinkedList.java)

· [Java 源码分析（LinkedList）](http://developer.classpath.org/doc/java/util/LinkedList-source.html)

· LRU Cache - Linked list：[ LRU 缓存机制](http://leetcode-cn.com/problems/lru-cache)

```java
class LRUCache {

    private Map<Integer,ListNode> map;

    private class ListNode {
        private Integer key;
        private Integer value;
        private ListNode pre;
        private ListNode next;

        public ListNode() {
        }

        public ListNode(Integer key, Integer value) {
            this.key = key;
            this.value = value;
        }
    }

        private int capacity;
        /**
         * 虚拟头结点没有前驱
         */
        private ListNode dummyHead;
        /**
         * 虚拟尾结点没有后继
         */
        private ListNode dummyTail;



        public LRUCache(int capacity) {
            map = new HashMap<>(capacity);
            this.capacity = capacity;
            dummyHead = new ListNode(-1,-1);
            dummyTail = new ListNode(-1,-1);
            // 初始化链表为 head <-> tail
            dummyHead.next = dummyTail;
            dummyTail.pre = dummyHead;
        }
        /**
         * 如果存在，把当前结点移动到双向链表的头部
         *
         * @param key
         * @return
         */
        public int get(int key) {
            if (map.containsKey(key)) {
                ListNode node = map.get(key);
                int val = node.value;

                // 把当前 node 移动到双向链表的头部
                moveNode2Head(key);
                return val;
            }else {
                return -1;
            }
        }
        /**
         * 如果哈希表的容量满了，就要删除一个链表末尾元素，然后在链表头部插入新元素
         *
         * @param key
         * @param value
         */
        public void put(int key, int value) {
            if (map.containsKey(key)) {
                map.get(key).value = value;
                moveNode2Head(key);
                return;
            }

            if (map.size() == capacity) {
                ListNode oldTail = removeTail();

                map.remove(oldTail.key);
            }

            ListNode newNode = new ListNode(key,value);
            map.put(key,newNode);
            addNode2Head(newNode);
        }

        private ListNode removeTail() {
            ListNode oldTail = dummyTail.pre;
            ListNode newTail = oldTail.pre;

            newTail.next = dummyTail;
            dummyTail.pre = newTail;

            oldTail.pre = null;
            oldTail.next = null;

            return oldTail;
        }

        private void moveNode2Head(int key) {
            ListNode node = map.get(key);
            // 2、原来 node 的前驱和后继接上
            node.pre.next = node.next;
            node.next.pre = node.pre;
            // 3、再把 node 放在开头
            addNode2Head(node);

        }

        private void addNode2Head(ListNode newnode) {
            ListNode oldHead = dummyHead.next;


            oldHead.pre = newnode;

            newnode.pre = dummyHead;
            newnode.next = oldHead;

            dummyHead.next = newnode;
        }

    }

```

· Redis - Skip List：[[跳跃表]]
[为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？](http://www.zhihu.com/question/20202931)

 

[[两数之和题目]]：(https://leetcode-cn.com/problems/two-sum/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n;j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i,j};
                }
            }
        }
        return new int[0];
    }
}
```

### Array 实战题目
##### [11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/)


```java
class Solution {
    public int maxArea(int[] height) {
        int i = 0,j = height.length -1,res = 0;

        while (i<j) {
            res = height[i] < height[j] ? Math.max(res,(j-i)*height[i++]):
                    Math.max(res,(j-i)*height[j--]);
        }
        return res;
    }
}
```

· https://leetcode-cn.com/problems/move-zeroes/

```java
//solution-1
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null) {
            return;
        }
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }

        for (int i = j; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}


//Solution : 2
class Solution {
    public void moveZeroes(int[] nums) {
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[j] = nums[i];
                if (i != j) {
                    nums[i] = 0;
                }
                j++;
            }
        }
    }
}
```

· https://leetcode-cn.com/problems/climbing-stairs/

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];

    }
}

//Solution-2
class Solution {
    private int[] cache;

    public int climbStairs(int n) {
        cache = new int[n+1];
        return calcways(n);
    }
    public int calcways(int n) {
        if (cache[n] != 0) return cache[n];
        if (n == 0) return 1;
        if (n == 1) return 1;
        cache[n] = calcways(n-1) + calcways(n-2);
        return cache[n];
    }
}
```

· [https://leetcode-cn.com/problems/3sum/ ](https://leetcode-cn.com/problems/3sum/)(高频老题）

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for (int k = 0; k < nums.length - 2; k++) {
            if (nums[k] > 0 ) break;
            if (k > 0 && nums[k] == nums[k - 1]) continue;
            int i = k + 1, j = nums.length - 1;
            while (i < j) {
                int sum = nums[k] + nums[i] + nums[j];
                if (sum < 0) {
                    while (i < j && nums[i] == nums[++i]);
                }else if (sum > 0) {
                    while (i < j && nums[j] == nums[--j]);
                }else {
                    res.add(new ArrayList<Integer>(Arrays.asList(nums[k],nums[i],nums[j])));
                    while (i < j && nums[i] == nums[++i]);
                    while (i < j && nums[j] == nums[--j]);
                }
            }

        }
        return res;

    }
}
```

### Linked List 实战题目

##### [203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        
        if(head == null) {
            return head;
        }

        ListNode dummy = new ListNode(-1,head);
        ListNode pre = dummy;
        ListNode cur = head;

        while(cur != null) {
            if(cur.val == val) {
                pre.next = cur.next;
                
            }else {
                pre = cur;
            }
            cur = cur.next;
        }
        return dummy.next;
    }
}
```

##### [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)

```java
//单链表
class MyLinkedList {

    int size;

    ListNode head;

    
    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }
    
    public int get(int index) {
        if(index < 0 || index >= size) {
            return -1;
        } 
        ListNode currentNode = head;

        for(int i = 0; i<=index;i++) {
            currentNode = currentNode.next;
        }
        return currentNode.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    
    public void addAtIndex(int index, int val) {
        if(index>size) {
            return;
        }
        if(index<0) {
            index = 0;
        }
        
        size++;

        ListNode pre = head;
        for(int i = 0;i< index;i++) {
            pre = pre.next;
        }

        ListNode toAdd = new ListNode(val);
        toAdd.next = pre.next;
        pre.next = toAdd;
    }
    
    public void deleteAtIndex(int index) {
        if(index>=size || index <0){
            return;
        }
        size--;
        ListNode pre = head;
        for(int i = 0;i<index;i++) {
            pre = pre.next;
        }
        pre.next = pre.next.next;
    }
}

class ListNode {
    int val;
    ListNode next;
    ListNode() {

    }
    ListNode(int val) {
        this.val = val;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
//双链表
class MyLinkedList {

    int size;

    ListNode head,tail;

    
    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
        tail = new ListNode(0);
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int index) {
        if(index >= size) {
            return -1;
        }

        ListNode currentNode = head;
        
        if(index >= size /2) {
            currentNode = tail;

            for(int i = 0;i < size-index;i++) {
                currentNode = currentNode.prev;
            }

        }else {
            currentNode = head;

            for(int i = 0;i<= index;i++) {
                currentNode = currentNode.next;
            }

        }
        return currentNode.val;

    
    }
    
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    
    public void addAtIndex(int index, int val) {
        if(index > size) {
            return;
        }

        size++;

        ListNode pre = head;

        for(int i = 0;i<index;i++) {
            pre = pre.next;
        }

        ListNode newNode = new ListNode(val);
        newNode.next = pre.next;
        pre.next.prev = newNode;
        newNode.prev = pre;
        pre.next = newNode;
    }
    
    public void deleteAtIndex(int index) {
        if(index >= size) {
            return;
        }

        size--;

        ListNode pre = head;

        for(int i =0 ;i<index;i++) {
            pre = pre.next;
        }

        // pre.next = pre.next.next; wrong
        // pre = pre.next.prev;
        pre.next.next.prev = pre;
        pre.next = pre.next.next;

    }

}

class ListNode {
    int val;
    ListNode next,prev;
    ListNode() {

    }
    ListNode(int val) {
        this.val = val;
    }
}
```

##### [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while ( curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }
}
```

##### [24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode next = head.next;
        head.next = swapPairs(next.next);
        next.next = head;
        return next;

    }
}
```

##### [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummyNode = new ListNode(0);

        dummyNode.next = head;

        ListNode fast = dummyNode;
        ListNode slow = dummyNode;
        
        for(int i = 0 ;i<n;i++) {
            fast = fast.next;
        }

        while(fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummyNode.next;

    }
}
```

##### [面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;

        int lenA = 0,lenB = 0;

        while(curA != null) {
            lenA++;
            curA = curA.next;
        }

        while(curB != null) {
            lenB++;
            curB = curB.next;
        }

        curA = headA;
        curB = headB;

        if(lenB > lenA) {
            int tmpLen = lenA;
            lenA = lenB;
            lenB = tmpLen;

            ListNode tmpNode = curA;
            curA = curB;
            curB = tmpNode;
        }

        int gap = lenA - lenB;
        while(gap-- > 0) {
            curA = curA.next;
        }

        while(curA != null) {
            if(curA == curB) {
                return curA;
            }
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }
}
```

##### [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/)

```java

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
}
//2
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while(head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
```

##### [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        
        ListNode slow = head;
        ListNode fast = head;

        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if(slow == fast) {
                ListNode index1 = fast;
                ListNode index2 = head;
                while(index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```

##### [25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode pre = dummy;
        ListNode end = dummy;
        while (end.next != null) {
            for (int i = 0; i < k && end != null;i++) end = end.next;
            if (end == null) break;
            ListNode start = pre.next;
            ListNode next = end.next;
            end.next = null;
            pre.next = reverse(start);
            start.next = next;
            pre = start;

            end = pre;
        }
        return dummy.next;
    }

    private ListNode reverse(ListNode head) {
        ListNode pre = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
    }
}
```



### 课后作业

· https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

· https://leetcode-cn.com/problems/rotate-array/

```java
//Solution-1
class Solution {
    public void rotate(int[] nums, int k) {
        if(k > nums.length) {
            k = k %nums.length;
        }

        int[] result = new int[nums.length];

        for (int i = 0; i < k; i++) {
            result[i] = nums[nums.length-k+i];
        }
        int j = 0;
        for (int i = k; i < nums.length; i++) {
            result[i] = nums[j];
            j++;
        }
        System.arraycopy(result,0,nums,0,nums.length);
    }

}
//Solution-2-Bubble Rotate
class Solution {
    public void rotate(int[] nums, int k) {
        for (int i = 0; i < k; i++) {
            for (int j = nums.length - 1; j > 0; j--) {
                int temp = nums[j];
                nums[j] = nums[j-1];
                nums[j-1] = temp;
            }
        }

    }

}
//Solution-3
class Solution {
    public void rotate(int[] nums, int k) {
//        k %= nums.length; //防止数组越界
        reverse(nums, 0, nums.length-1);
        reverse(nums,0, k-1);
        reverse(nums,k, nums.length-1);

    }

    public void reverse(int[] nums,int start,int end) {
        while (start < end ) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start += 1;
            end -= 1;
        }
    }
}
```

· https://leetcode-cn.com/problems/merge-two-sorted-lists/

· https://leetcode-cn.com/problems/merge-sorted-array/

· https://leetcode-cn.com/problems/plus-one/

## 04栈、队列、优先队列、双端队列

### 参考链接

· [Java 的 PriorityQueue 文档](http://docs.oracle.com/javase/10/docs/api/java/util/PriorityQueue.html)

· [Java 的 Stack 源码](http://developer.classpath.org/doc/java/util/Stack-source.html)

· [Java 的 Queue 源码](http://fuseyism.com/classpath/doc/java/util/Queue-source.html)

· [Python 的 heapq](http://docs.python.org/2/library/heapq.html)

· [高性能的 container 库](http://docs.python.org/2/library/collections.html)

### 预习题目

· https://leetcode-cn.com/problems/valid-parentheses/

· https://leetcode-cn.com/problems/min-stack/

### 实战题目

· https://leetcode-cn.com/problems/largest-rectangle-in-histogram

```java
//单调栈
class Solution {
    int largestRectangleArea(int[] heights) {
        Stack<Integer> st = new Stack<Integer>();
        
        // 数组扩容，在头和尾各加入一个元素
        int[] newHeights = new int[heights.length + 2];
        newHeights[0] = 0;
        newHeights[newHeights.length - 1] = 0;
        for (int index = 0; index < heights.length;index++) {
            newHeights[index + 1] = heights[index];
        }
        
        heights = newHeights;
        
        st.push(0);
        int result = 0;
        // 第一个元素已经入栈，从下标1开始
        for(int i = 1;i < heights.length;i++) {
            // 注意heights[i] 是和heights[st.top()] 比较 ，st.top()是下标
            if(heights[i] > heights[st.peek()]) {
                st.push(i);
            }else if(heights[i] == heights[st.peek()]) {
                st.pop(); // 这个可以加，可以不加，效果一样，思路不同
                st.push(i);
            }else {
                while(heights[i] < heights[st.peek()]) {
                    int mid = st.peek();
                    st.pop();
                    int left = st.peek();
                    int right = i;
                    int w = right - left - 1;
                    int h = heights[mid];
                    result = Math.max(result,w * h);
                }
                st.push(i);
            }
        }
        return result;
    }
}
```

##### [239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/)

```java
//解法一
//自定义数组
class MyQueue {
    Deque<Integer> deque = new LinkedList<>();
    //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出
    //同时判断队列当前是否为空
    void poll(int val) {
        if (!deque.isEmpty() && val == deque.peek()) {
            deque.poll();
        }
    }
    //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出
    //保证队列元素单调递减
    //比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2
    void add(int val) {
        while (!deque.isEmpty() && val > deque.getLast()) {
            deque.removeLast();
        }
        deque.add(val);
    }
    //队列队顶元素始终为最大值
    int peek() {
        return deque.peek();
    }
}

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 1) {
            return nums;
        }
        int len = nums.length - k + 1;
        //存放结果元素的数组
        int[] res = new int[len];
        int num = 0;
        //自定义队列
        MyQueue myQueue = new MyQueue();
        //先将前k的元素放入队列
        for (int i = 0; i < k; i++) {
            myQueue.add(nums[i]);
        }
        res[num++] = myQueue.peek();
        for (int i = k; i < nums.length; i++) {
            //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列
            myQueue.poll(nums[i - k]);
            //滑动窗口加入最后面的元素
            myQueue.add(nums[i]);
            //记录对应的最大值
            res[num++] = myQueue.peek();
        }
        return res;
    }
}

//解法二
//利用双端队列手动实现单调队列
/**
 * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可
 * 单调队列类似 （tail -->） 3 --> 2 --> 1 --> 0 (--> head) (右边为头结点，元素存的是下标)
 */
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        int n = nums.length;
        int[] res = new int[n - k + 1];
        int idx = 0;
        for(int i = 0; i < n; i++) {
            // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点
            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出
            while(!deque.isEmpty() && deque.peek() < i - k + 1){
                deque.poll();
            }
            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出
            while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            deque.offer(i);

            // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了
            if(i >= k - 1){
                res[idx++] = nums[deque.peek()];
            }
        }
        return res;
    }
}
```

### 课后作业

· 用 add first 或 add last 这套新的 API 改写 Deque 的代码

|                    | Queue                  | Deque                           |
| :----------------- | :--------------------- | ------------------------------- |
| 添加元素到队尾     | add(E e) / offer(E e)  | addLast(E e) / offerLast(E e)   |
| 取队首元素并删除   | E remove() / E poll()  | E removeFirst() / E pollFirst() |
| 取队首元素但不删除 | E element() / E peek() | E getFirst() / E peekFirst()    |
| 添加元素到队首     | 无                     | addFirst(E e) / offerFirst(E e) |
| 取队尾元素并删除   | 无                     | E removeLast() / E pollLast()   |
| 取队尾元素但不删除 | 无                     | E getLast() / E peekLast()      |

Deque的实现
 既然Deque是个接口所以初始化时就要用到其具体的实现，在 Collections API中有下面两种实现:

- java.util.LinkedList
- java.util.ArrayDeque

LinkedList类是非常标准的Deque和Queue的实现，它在内部使用链接列表来建模queue或deque。

```java
Deque deque = new LinkedList();
Deque deque = new ArrayDeque();
```

· 分析 Queue 和 Priority Queue 的源码

· https://leetcode-cn.com/problems/design-circular-deque

```java
class MyCircularDeque {
    int[] queue;
    int front;
    int rear;
    int k;
    int size;

    public MyCircularDeque(int k) {
        queue = new int[k];
        front = 0;
        rear = 0;
        this.k = k;
        size = 0;
    }
//头部，先赋值，再移位，所以当前front指向的是可用的位置，并不是头，头需要(front + 1) % k算得位置。
    public boolean insertFront(int value) {
		if(size == k) {
            return false;
        }else {
            queue[front] = value;
            front--;
            front = (front + k) % k;
            size++;
            return true;
        }
    }
//尾部，先移位，再赋值，所以当前rear指向是尾部。尾部就是queue[rear]
    public boolean insertLast(int value) {
		if(size == k) {
            return false;
        }else {
            rear++;
            rear = rear % k;
            queue[rear] = value;
            size++;
            return true;
        }
    }

    public boolean deleteFront() {
		if(size == 0) {
            return false;
        }else {
            front++;
            front = front % k;
            size--;
            return true;
        }
    }

    public boolean deleteLast() {
		if(size == 0) {
            return false;
        }else {
            rear--;
            rear = (rear + k) % k;
            size--;
            return true;
        }
    }

    public int getFront() {
		if(size == 0) {
            return -1;
        }else{
            return queue[(front+1)%k];
        }
    }

    public int getRear() {
		if(size == 0) {
            return -1;
        }else {
            return queue[rear];
        }
    }

    public boolean isEmpty() {
		return size == 0;
    }

    public boolean isFull() {
		return size == k;
    }
}
```



· https://leetcode-cn.com/problems/trapping-rain-water/

```java
public int trap(int[] height) {
    int sum = 0;
    //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2
    for(int i = 1; i< height.length - 1;i++) {
        int max_left = 0;
        //找出左边最高
        for(int j = i-1;j>=0;j--) {
            if(height[j]>max_left) {
                max_left = height[j];
            }
        }
        //找出右边最高
        int max_right = 0;
        for(int j = i+1;j<height.length;j++) {
            if(height[j]>max_right) {
                max_right = height[j];
            }
        }
         //找出两端较小的
        int min = Math.min(max_left,max_right);
        //只有较小的一段大于当前列的高度才会有水，其他情况不会有水
        if(min>height[i]) {
            sum = sum + (min - height[i]);
        }
        
    }
    return sum;
}
```



说明：改写代码和分析源码这两项作业，同学们需要在第 1 周的学习总结中完成。如果不熟悉 Java 语言，这两项作业可选做。

## 05哈希表、映射、集合

### 参考链接

· [Java Set 文档](http://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Set.html)

· [Java Map 文档](http://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Map.html)

### 课后作业

写一个关于 HashMap 的小总结。
说明：对于不熟悉 Java 语言的同学，此项作业可选做。

### 实战题目 / 课后作业

· https://leetcode-cn.com/problems/valid-anagram/description/

```java
class soulution {
    public boolean isAnagram(String s,String t) {
        if(s.length() != t.length()) return false;
        int[] alpha = new int[26];
        for(int i = 0;i<s.length;i++) {
            alpha[s.charAt(i) - 'a']++;
            alpha[t.charAt(i) - 'a']--;
        }
        for(int i = 0;i<26;i++) {
            if(alpha[i] != 0)
                return false;
        }
        return true;
    }
}
```

· https://leetcode-cn.com/problems/group-anagrams/

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> chars = new HashMap<>();
        for (String s : strs) {
            char[] t = s.toCharArray();
            Arrays.sort(t);
            String k = new String(t);
            chars.computeIfAbsent(k, key -> new ArrayList<>()).add(s);
        }
        return new ArrayList<>(chars.values());
    }
}
```

```java
/*
 只有在当前 Map 中 key 对应的值不存在或为 null 时
 才调用 mappingFunction
 并在 mappingFunction 执行结果非 null 时
 将结果跟 key 关联．
 mappingFunction 为空时 将抛出空指针异常
*/

// 函数原型 支持在 JDK 8 以上
public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)


Map<String, List<String>> map = new HashMap<>();
List<String> list;

// 一般这样写
list = map.get("list-1");
if (list == null) {
    list = new LinkedList<>();
    map.put("list-1", list);
}
list.add("one");

// 使用 computeIfAbsent 可以这样写
list = map.computeIfAbsent("list-1", k -> new ArrayList<>());
list.add("one");
```

· https://leetcode-cn.com/problems/two-sum/description/

```java
public int[] twoSum(int[] nums,int target) {
    int[] res = new int[2];
    if(nums == null || nums.length == 0) {
        return res;
    }
    Map<Integer, Integer> map = new HashMap<>();
    for(int i = 0;i < nums.length;i++) {
        int temp = target - nums[i];
        if(map.containsKey(temp)) {
            res[1] = i;
            res[0] = map.get(temp);
        }
        map.put(nums[i],i);
    }
    return res;
}
```

![](F:\LearninginUniversity\2022——自学\笔记\img\1.两数之和.gif)

### 参考链接

· 养成收藏精选代码的习惯（示例）

 Anagram, group-anagrams, two sum

Valid anagram

```python
# 思路：手动模拟hashtable，将字符串”a-z“的ASCII码作key，计数求差异
def  isAnagram(self, s: str, t: str) -> bool:        
    arr1, arr2 = [0]*26, [0]*26       
    for i in s:            
        arr1[ord(i) - ord('a')] += 1        
    for i in t:            
        arr2[ord(i) - ord('a')] += 1       
    return arr1 == arr2
```

```python
# 思路：map计数，对比计数差异
    def isAnagram(self, s: str, t: str) -> bool:        
        dict1, dict2 = {}, {}        
        for item in s:            
            dict1[item] = dict1.get(item,0) + 1        
        for item in t:            
            dict2[item] = dict2.get(item,0) + 1        
        return dict1 == dict2
```

```python
# 思路：数组排序后比较差异    
def isAnagram(self, s: str, t: str) -> bool:        
	return sorted(s) == sorted(t)
```

```java
public class Solution {    
    public boolean isAnagram(String s, String t) {        
        if(s.length() != t.length()) return false;        
        int [] a = new int [26];        
        for(Character c : s.toCharArray()) a[c - 'a']++;        				
        for(Character c : t.toCharArray()) {            
            if(a[c -'a'] == 0) return false;            
            a[c - 'a']--;        
        }        
        return true;    
    }
}
```

```java
public boolean isAnagram(String s1, String s2) {        
    int[] freq = new int[256];        
    for(int i = 0; i < s1.length(); i++) freq[s1.charAt(i)]++;        		
    for(int i = 0; i < s2.length(); i++) 
        if(--freq[s2.charAt(i)] < 0) return false;        
    return s1.length() == s2.length();   
}
```

```java
public boolean isAnagram(String s, String t) {
    char[] sChar = s.toCharArray();
    char[] tChar = t.toCharArray();
    Arrays.sort(sChar);
    Arrays.sort(tChar);
    return Arrays.equals(sChar, tChar);   

}
```

Group Anagrams:

```python
def groupAnagrams(self, strs):    
    d = {}    
    for w in sorted(strs):        
        key = tuple(sorted(w))        
        d[key] = d.get(key, []) + [w]    
    return d.values()
```

```java
def groupAnagrams(self, strs):

dic = {}

for item in sorted(strs):

	sortedItem = ''.join(sorted(item))

    dic[sortedItem] = dic.get(sortedItem, []) + [item]

return dic.values()
```

```java
public List<List<String>> groupAnagrams(String[] strs) {

    List<List<String>> res = new ArrayList<>();

    HashMap<String, List<String>> map = new HashMap<>();
    Arrays.sort(strs);
    for (int i = 0; i < strs.length; i++) {
        String temp = strs[i];
        char[] ch = temp.toCharArray();
        Arrays.sort(ch);
        if (map.containsKey(String.valueOf(ch))) {
            //String.valueOf(char c) : 将 char 变量 c 转换成字符串
            map.get(String.valueOf(ch)).add(strs[i]);
        } else {
            List<String> each = new ArrayList<>();
            each.add(strs[i]);
            map.put(String.valueOf(ch), each);
        }
    }
    for (List<String> item: map.values()) {
        res.add(item);
    }
    return res;
}
```

Two sum

```python
def twoSum(self, nums, target):

    d = dict()
    for index,num in enumerate(nums):
        if d.get(num) == None:
            d[target - num] = index
        else:
            return [d.get(num), index]
```

```java
public int[] twoSum(int[] nums, int target) {

    HashMap<Integer, Integer> tracker = 
        new HashMap<Integer, Integer>();
    int len = nums.length;
    for (int i = 0; i < len; i++){
        if (tracker.containsKey(nums[i])){
            int left = tracker.get(nums[i]);
            return new int[]{left+1, i+1};
        } else {
            tracker.put(target - nums[i], i);
        }
    }
    return new int[2];

}
```



## 06树、二叉树、二叉搜索树

### 参考链接
[二叉树](./二叉树.md)
[[二叉树]]
### 思考题

树的面试题解法一般都是递归，为什么？
说明：同学们可以将自己的思考写在课程下方的留言区一起讨论，也可以写在第 2 周的学习总结中。

### 参考链接

· [树的遍历 Demo](https://visualgo.net/zh/bst)

### 实战题目 / 课后作业

##### [590. N 叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)

```java
class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> result = new ArrayList<>();
        postorder(root,result);
        return result;
    }

    void postorder(Node root,List<Integer> result) {
        if (root == null) return;
        for (Node ch : root.children) {
            postorder(ch,result);
        }
        result.add(root.val);

    }
}
```

##### [589. N 叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/description/)

```java
class Solution {
    public List<Integer> preorder(Node root) {
        List<Integer> result = new ArrayList<>();
        preorder(root,result);
        return result;
    }

    private void preorder(Node root, List<Integer> result) {
        if (root == null) return;
        for (Node ch : root.children) {
            preorder(ch,result);
        }

        result.add(root.val);
    }


}
```

##### [429. N 叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        if (root == null) return new ArrayList<List<Integer>>();

        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        Queue<Node> queue = new ArrayDeque<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int cnt = queue.size();
            List<Integer> level = new ArrayList<>();
            for (int i = 0; i < cnt; i++) {
                Node cur = queue.poll();
                level.add(cur.val);
                for (Node child : cur.children) {
                    queue.offer(child);
                }

            }
            ans.add(level);
        }
        return ans;
    }
}
```

## 07泛型递归、树的递归

### 参考链接

· 递归代码模板

```python
# Python 
def recursion(level, param1, param2, ...):     
    # recursion terminator     终止条件判断
    if level > MAX_LEVEL:        
        # process_result        
        return     

    # process logic in current level     当前递归逻辑处理
    process(level, data...)     

    # drill down       递归调用
    self.recursion(level + 1, p1, ...)    
     
    # reverse the current level status if needed     处理一些状态
```

 实战题目

· https://leetcode-cn.com/problems/climbing-stairs/

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];

    }
}

class Solution {
    private int[] cache;

    public int climbStairs(int n) {
        cache = new int[n+1];

        return calcways(n);

    }

    public int calcways(int n) {

        if (cache[n] != 0) return cache[n];
        if (n == 0) return 1;
        if (n == 1) return 1;

        cache[n] = calcways(n-1) + calcways(n-2);
        return cache[n];
    }
}
```

· https://leetcode-cn.com/problems/generate-parentheses/

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();

        if (n == 0) return res;
        dfs("",n,n,res);
        return res;
    }

    private void dfs(String curStr, int left, int right, List<String> res) {
        // 因为每一次尝试，都使用新的字符串变量，所以无需回溯
        // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分
        if (left == 0 && right == 0) {
            res.add(curStr);
            return;
        }
        // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）
        if (left > right) {
            return;
        }

        if (left > 0) {
            dfs(curStr + "(",left-1,right,res);
        }

        if (right < 0) {
            dfs(curStr+")",left,right - 1,res);
        }
    }
}
```

· https://leetcode-cn.com/problems/invert-binary-tree/description/

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;

        invertTree(root.left);
        invertTree(root.right);
        swapChildren(root);
        return root;
    }

    private void swapChildren(TreeNode root) {
        TreeNode temp = root.right;
        root.right = root.left;
        root.left = temp;
    }
}
```

· https://leetcode-cn.com/problems/validate-binary-search-tree

```java
class Solution {
    private long prev = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;

        if (!isValidBST(root.left)) {
            return false;
        }

        if (root.val <= prev) {
            return false;
        }

        prev = root.val;
        return isValidBST(root.right);

    }
}
```

· https://leetcode-cn.com/problems/maximum-depth-of-binary-tree

```java
class Solution {
//    int depth = 0;
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;

//        depth++;

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);

        return Math.max(left,right) + 1;


    }
}
```

· https://leetcode-cn.com/problems/minimum-depth-of-binary-tree

```java
class Solution {

    public int minDepth(TreeNode root) {
        if (root == null) return 0;

        int left = minDepth(root.left);
        int right = minDepth(root.right);

        return Math.min(left,right) + 1;
    }
}
```

· https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/

```java
public class Codec {

    private static final String NULL = "#";
    private static final String SEP = ",";
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        preorder(root,sb);
        return sb.toString();
    }

    private void preorder(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL + SEP);
            return;
        }

        sb.append(root.val + SEP);
        preorder(root.left,sb);
        preorder(root.right,sb);
    }


    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data == null || "".equals(data)) {
            return null;
        }

        List<String> vals = new LinkedList<>();
        for (String x : data.split(SEP)) {
            vals.add(x);
        }
        return deserialize(vals);
    }

    private TreeNode deserialize(List<String> vals) {
        String first = vals.remove(0);
        if (NULL.equals(first)) {
            return null;
        }

        TreeNode root = new TreeNode(Integer.parseInt(first));
        root.left = deserialize(vals);
        root.right = deserialize(vals);
        return root;
    }
}
```



### 课后作业

· https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root ==null || root == p || root == q) {
            return root;
        }

        TreeNode rootLeft = lowestCommonAncestor(root.left,p,q);
        TreeNode rootRight = lowestCommonAncestor(root.right,p,q);

        if(rootLeft == null && rootRight == null) {
            return null;
        }else if (rootLeft == null && rootRight != null) {
            return rootRight;
        }else if (rootLeft != null && rootRight == null) {
            return rootLeft;
        }else {
            return root;
        }
    }
}
```



· https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return helper(preorder,0,preorder.length-1,
                inorder,0,inorder.length-1);
    }

    private TreeNode helper(int[] preorder, int preLeft, int preRight, int[] inorder,int inLeft, int inRight) {
        if (preLeft > preRight || inLeft > inRight) return null;
        int idx = inLeft,val = preorder[preLeft];
        TreeNode root = new TreeNode(val);
        for (int i = inLeft; i <= inRight; i++) {
            if (inorder[i] == val) {
                idx = i;
                break;
            }
        }

        root.left = helper(preorder,preLeft+1,preLeft + (idx - inLeft),inorder,inLeft,idx-1);
        root.right = helper(preorder,preLeft + (idx - inLeft) + 1,preRight,inorder,idx+1,inRight);

        return root;
    }
}
```

· https://leetcode-cn.com/problems/combinations/

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();

        if (k<= 0 && n < k) {
            return res;
        }
        // 从 1 开始是题目的设定
        Deque<Integer> path = new ArrayDeque<>();
        dfs(n,k,1,path,res);
        return res;

    }

    private void dfs(int n, int k, int begin, Deque<Integer> path, List<List<Integer>> res) {
        // 递归终止条件是：path 的长度等于 k
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }
		// 遍历可能的搜索起点
        for (int i = begin; i <= n; i++) {
            // 向路径变量里添加一个数
            path.addLast(i);
            // 下一轮搜索，设置的搜索起点要加 1，因为组合数理不允许出现重复的元素
            dfs(n,k,i+1,path,res);
            // 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作
            path.removeLast();

        }

    }
}
```

· https://leetcode-cn.com/problems/permutations/

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        List<List<Integer>> res = new ArrayList<>();

        if (len == 0) {
            return res;
        }
        boolean[] used = new boolean[len];
        List<Integer> path = new ArrayList<>();

        dfs(nums,len,0,path,used,res);

        return res;
    }

    private void dfs(int[] nums, int len, int depth, List<Integer> path, boolean[] used, List<List<Integer>> res) {

        if (len == depth) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0;i < len;i++) {
            if (!used[i]) {
                path.add(i);
                used[i] = true;
                dfs(nums,len,depth+1,path,used,res);
                used[i] = false;
                path.remove(path.size()-1);
            }
        }
    }
}
```

· https://leetcode-cn.com/problems/permutations-ii/

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        int len = nums.length;
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }
        // 剪枝的前提是排序
        Arrays.sort(nums);
        boolean[] used = new boolean[len];
        // 使用 Deque 是 Java 官方 Stack 类的建议
        Deque<Integer> path = new ArrayDeque<>();
        dfs(nums,0,len,used,path,res);
        return res;
    }

    private void dfs(int[] nums, int index, int len, boolean[] used, Deque<Integer> path, List<List<Integer>> res) {
        if (index == len) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0;i<len;i++) {
            if (used[i]) {
                continue;
            }
            // 注意：理解 !used[i - 1]，很关键
            // 剪枝条件：i > 0 是为了保证 nums[i - 1] 有意义
            // 写 !used[i - 1] 是因为 nums[i - 1] 在深度优先遍历的过程中刚刚被撤销选择
            if (i>0 && nums[i] == nums[i-1] && !used[i-1]) {
                continue;
            }

            path.addLast(nums[i]);
            used[i] = true;
            
            dfs(nums,i+1,len,used,path,res);
            // 回溯部分的代码，和 dfs 之前的代码是对称的
            used[i] = false;
            path.removeLast();
        }
    }
}
```

## 08分治、回溯

### 参考链接

· 分治代码模板

```java
//Java
private static int divide_conquer(Problem problem, ) {    
    if (problem == NULL) {    
        int res = process_last_result();    
        return res;       
    }  
    subProblems = split_problem(problem)   
    res0 = divide_conquer(subProblems[0])  
    res1 = divide_conquer(subProblems[1])    
    result = process_result(res0, res1);   
    return result;
}


```



##### [22. 括号生成 - 力扣（LeetCode）](https://leetcode.cn/problems/generate-parentheses/)

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();

        if (n == 0) return res;
        dfs("",n,n,res);
        return res;
    }

    private void dfs(String curStr, int left, int right, List<String> res) {
        // 因为每一次尝试，都使用新的字符串变量，所以无需回溯
        // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分
        if (left == 0 && right == 0) {
            res.add(curStr);
            return;
        }
        // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）
        if (left > right) {
            return;
        }

        if (left > 0) {
            dfs(curStr + "(",left-1,right,res);
        }

        if (right < 0) {
            dfs(curStr+")",left,right - 1,res);
        }
    }
}
```

 预习题目

· https://leetcode-cn.com/problems/powx-n/

```java
class Solution {
    public double myPow(double x, int n) {
        long b = n;
        if (n < 0) {
            return 1/myPow(x,-n);
        }
        return myPow(x,b);
    }

    double myPow(double x, long n) {
        if (n == 0) {
            return 1;
        }
        if (n % 2 == 1) {
            return myPow(x,n-1);
        }
        return myPow(x*x,n/2);
    }
}
```

· https://leetcode-cn.com/problems/subsets/

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        int len = nums.length;
        List<List<Integer>> res = new ArrayList<>();

        if (len == 0) return res;
        Deque<Integer> path = new ArrayDeque<>();
        dfs(nums,0,len,path,res);
        return res;
    }

    private void dfs(int[] nums, int index, int len, Deque<Integer> path, List<List<Integer>> res) {

        if (len == index) {
            res.add(new ArrayList<>(path));
            return;
        }
        // 不选 nums[index]，由于在 dfs 之前什么都没有操作，不用状态重置
        dfs(nums,index+1,len,path,res);
        // 选 nums[index]
        path.add(nums[index]);
        dfs(nums,index+1,len,path,res);
        // 回溯的位置：状态重置
        path.removeLast();
    }
}
```

### 参考链接

· [牛顿迭代法原理](http://www.matrix67.com/blog/archives/361)

· [牛顿迭代法代码](http://www.voidcn.com/article/p-eudisdmk-zm.html)

```java
public static double sqrt(double c) {
        if(c < 0) return Double.NaN;
        double err = 1e-15;
        double t = c;
        while(Math.abs(t-c/t)>err*t) {
            t = (c/t + t) /2.0;
        }
        return t;
}
```



 实战题目

· [https://leetcode-cn.com/problems/majority-element/description/ ](https://leetcode-cn.com/problems/majority-element/description/)（简单、但是高频）

```java
//投票法
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0,maj = 0;
        for (int num : nums) {
            if (count == 0) {
                maj = num;
                count = 1;
            }else {
                count += (maj==num) ? 1 : -1;
            }
        }
        return maj;
    }
}


```

· https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        int len = digits.length();
        if (len == 0) {
            return res;
        }
        String[] digitsMap = {"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        findCombinations(digits,digitsMap,0,"",res);
        return res;
    }
    /**
     * @param digits 原始字符串
     * @param start  从原始字符串的第几位开始搜索
     * @param pre    已经得到的子串
     */
    private void findCombinations(String digits, String[] digitsMap, int start, String pre, List<String> res) {
        if (start == digits.length()) {
            res.add(pre);
            return;
        }

        String nextStr = digitsMap[digits.charAt(start)-'2'];
        int len = nextStr.length();
        for (int i = 0; i< len;i++) {
            findCombinations(digits,digitsMap,start+1,pre+nextStr.charAt(i),res);
        }

    }
}
```

· https://leetcode-cn.com/problems/n-queens/

```java
class Solution {

    public List<List<String>> solveNQueens(int n) {
        List<List<String>> res = new ArrayList<>();
        String[][] g = new String[n][n];
        for (int i = 0; i < n; i++) {
            String[] t = new String[n];
            Arrays.fill(t,".");
            g[i] = t;
        }

        boolean[] col = new boolean[n];
        boolean[] main = new boolean[2*n];
        boolean[] sub = new boolean[2*n];
        dfs(0,n,col,main,sub,g,res);
        return res;

    }

    private void dfs(int row, int n, boolean[] col, boolean[] main, boolean[] sub, String[][] g, List<List<String>> res) {
        if (row == n) {
            List<String> t = new ArrayList<>();
            for (String[] e : g) {
                t.add(String.join("",e));
            }
            res.add(t);
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!col[i] && !main[row+i] && !sub[n-row+i]) {
                g[row][i] = "Q";
                col[i] = main[row+i] = sub[n-row+i] = true;

                dfs(row+1,n,col,main,sub,g,res);

                g[row][i] = ".";
                col[i] = main[row+i] = sub[n-row+i] = false;
            }
        }
    }


}
```

## 09深度优先搜索和广度优先搜索

### 参考链接

· [DFS 代码模板（递归写法、非递归写法）](http://shimo.im/docs/ddgwCccJQKxkrcTq)

```python
//递归
visited = set()
def dfs(node,visited) :
    if node in visited: #terminator
        #already visited
        return 
    
    visited.add(node)
    
    #process current node here
    ...
    for next_node in node.children():
        if next_node not in visited:
            dfs(next_node,visited)
            

            
//非递归
def DFS(self,root)

	if tree.root is None:
        return []
    
    visited,stack = [],[root]
    
    while stack:
        node = stack.pop()
        visited.add(node)
        
        process(node)
        
        #生成相关的节点
        nodes = gennerate_related_nodes(node)
        stack.push(nodes)
         
     #other processing work   
```



```java
//Java

public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> allResults = new ArrayList<>();
    if(root==null){
        return allResults;
    }
    travel(root,0,allResults);
    return allResults;
}

private void travel(TreeNode root,int level,List<List<Integer>> results){
    if(results.size()==level){
        results.add(new ArrayList<>());
    }

    results.get(level).add(root.val);
    if(root.left!=null){
        travel(root.left,level+1,results);
    }

    if(root.right!=null){
        travel(root.right,level+1,results);
    }
}
```

· [BFS 代码模板](http://shimo.im/docs/P8TqKHGKt3ytkYYd)

```python
def BFS(graph,start,end):
	queue = []
	queue.append([start])
	visited.add(start)
	
	while queue:
        node = queue.pop()
        visited.add(node)
        
        process(node)
        nodes = generate_related_nodes(node)
        queue.push(nodes)
        
     #other processing work
    ...
```

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) {
        val = x;
    }
}

public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> allResults = new ArrayList<>();
    if (root == null) {
        return allResults;
    }

    Queue<TreeNode> nodes = new LinkedList<>();
    nodes.add(root);
    while (!nodes.isEmpty()) {
        int size = nodes.size();
        List<Integer> results = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            TreeNode node = nodes.poll();
            results.add(node.val);
            if (node.left != null) {
                nodes.add(node.left);
            }
            if (node.right != null) {
                nodes.add(node.right);
            }
        }
        allResults.add(results);
    }
    return allResults;
}
```

###  实战题目

##### [102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/#/description)



##### [433. 最小基因变化 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-genetic-mutation/#/description)

```java
class Solution {
    private int ans;
    private Set<String> set;
    private final char[] seq = {'A','C','G','T'};

    public int minMutation(String start, String end, String[] bank) {
        set = new HashSet<>();
        for (String b : bank) {
            set.add(b);
        }
        ans = Integer.MAX_VALUE;
        dfs(start,end,0);
        set.remove(start);
        return ans == Integer.MAX_VALUE ? -1:ans;
    }

    private void dfs(String start, String end, int t) {
        if (start.equals(end)) {
            ans = Math.min(ans,t);
            return;
        }

        for (int i = 0; i < start.length(); i++) {
            for (char c : seq) {
                if (start.charAt(i) == c) {
                    continue;
                }

                String next = start.substring(0,i) + c + start.substring(i+1);
                if (set.contains(next)) {
                    set.remove(next);
                    dfs(next,end,t+1);
                }
            }

        }


    }
}
```

##### [515. 在每个树行中找最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/#/description)

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> res = new ArrayList<>();

        if (root == null) {
            return res;
        }
        Deque<TreeNode> q = new ArrayDeque<>();
        q.offer(root);
        while(!q.isEmpty()) {
            int t = Integer.MIN_VALUE;
            for (int i = q.size(); i > 0 ; i--) {
                TreeNode node = q.poll();
                t = Math.max(t, node.val);
                if (node.left != null) {
                    q.offer(node.left);
                }
                if (node.right != null) {
                    q.offer(node.right);
                }
            }
            res.add(t);
        }
        return res;

    }

}
```

### 课后作业

##### [127. 单词接龙 - 力扣（LeetCode）](https://leetcode.cn/problems/word-ladder/description/)

```java
//朴素 BFS：
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> words = new HashSet<>(wordList);
        Queue<String> q = new ArrayDeque<>();
        
        q.offer(beginWord);
        int ans = 1;
        while (!q.isEmpty()) {
            ++ans;
            for (int i = q.size(); i > 0 ; i--) {
                String s = q.poll();
                char[] chars = s.toCharArray();
                for (int j = 0; j < chars.length; j++) {
                    char ch = chars[j];
                    for (char k = 'a';k <= 'z';k++) {
                        chars[j] = k;
                        String t = new String(chars);
                        if (!words.contains(t)) {
                            continue;
                        }
                        if (endWord.equals(t)) {
                            return ans;
                        }
                        q.offer(t);
                        words.remove(t);
                    }
                    chars[j] = ch;

                }

            }
        }
        return 0;
    }
}
//shuang'xian
class Solution {
    private Set<String> words;
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {

        words = new HashSet<>(wordList);
        if (!words.contains(endWord)) {
            return 0;
        }

        Queue<String> q1 = new ArrayDeque<>();
        Queue<String> q2 = new ArrayDeque<>();
        Map<String,Integer> m1 = new HashMap<>();
        Map<String,Integer> m2 = new HashMap<>();
        q1.offer(beginWord);
        q2.offer(endWord);
        m1.put(beginWord,0);
        m2.put(endWord,0);
        while(!q1.isEmpty() && !q2.isEmpty()) {
            int t = q1.size() <= q2.size() ? extend(m1,m2,q1) : extend(m2,m1,q2);
            if (t != -1) {
                return t + 1;
            }
        }
        return 0;

    }

    private int extend(Map<String, Integer> m1, Map<String, Integer> m2, Queue<String> q) {
        for (int i = q.size();i>0;i--) {
            String s = q.poll();
            int step = m1.get(s);
            char[] chars = s.toCharArray();
            for (int j = 0; j < chars.length; j++) {
                char ch = chars[j];
                for (char k = 'a';k <= 'z';k++) {
                    chars[j] = k;
                    String t = new String(chars);
                    if (!words.contains(t) || m1.containsKey(t)) {
                        continue;
                    }
                    if (m2.containsKey(t)) {
                        return step + 1 + m2.get(t);
                    }
                    q.offer(t);
                    m1.put(t,step+1);
                }
                chars[j] = ch;

            }
        }
        return -1;
    }
}
```

· https://leetcode-cn.com/problems/word-ladder-ii/description/



· https://leetcode-cn.com/problems/number-of-islands/

```java
//DFS - Flood Fill 算法：
class Solution {
    private char[][] grid;
    private int row;
    private int colu;

    public int numIslands(char[][] grid) {
        row = grid.length;
        colu = grid[0].length;

        this.grid = grid;

        int ans = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < colu; j++) {
                if (grid[i][j] == '1') {
                    dfs(i,j);
                    ++ans;
                }
            }
        }
        return ans;

    }

    private void dfs(int i, int j) {
        grid[i][j] = '0';
        int[] dirs = {-1,0,1,0,-1};
        for (int k = 0; k < 4; k++) {
            int x = i + dirs[k];
            int y = j + dirs[k+1];
            if (x >= 0 && x < row && y >= 0 && y<colu && grid[x][y] == '1'){
                dfs(x,y);
            }
        }
    }
}

//BFS - Flood Fill 算法：
class Solution {
    private char[][] grid;
    private int row;
    private int colu;

    public int numIslands(char[][] grid) {
        row = grid.length;
        colu = grid[0].length;

        this.grid = grid;

        int ans = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < colu; j++) {
                if (grid[i][j] == '1') {
                    bfs(i,j);
                    ++ans;
                }
            }
        }
        return ans;

    }

    private void bfs(int i, int j) {
        grid[i][j] = '0';
        Deque<int[]> q = new ArrayDeque<>();
        q.offer(new int[]{i,j});
        int[] dirs = {-1,0,1,0,-1};
        while(!q.isEmpty()) {
            int[] p = q.poll();
            for (int k = 0; k < 4;k++) {
                int x = p[0] + dirs[k];
                int y = p[1] + dirs[k+1];
                if (x >= 0 && x < row && y>= 0&& y < colu && grid[x][y] == '1') {
                    q.offer(new int[]{x,y});
                    grid[x][y] = '0';
                }
            }
        }
    }


}
//并查集：

```

· https://leetcode-cn.com/problems/minesweeper/description/

```java
//dfs
class Solution {

    private int[][] directions = {{0,1},{1,0},{0,-1},{-1,0},{1,1},{-1,-1},{1,-1},{-1,1}};
    private int rows;
    private int cols;
    public char[][] updateBoard(char[][] board, int[] click) {
        this.rows = board.length;
        this.cols = board[0].length;

        int x = click[0];
        int y = click[1];
        if (board[x][y] == 'M') {
            // 规则 1
            board[x][y] = 'X';
            return board;
        }
        dfs(board,x,y);
        return board;

    }

    private void dfs(char[][] board, int x, int y) {
        // 相邻地雷的数量
        int count = 0;
        for (int[] direction : directions) {
            int newX = x + direction[0];
            int newY = y + direction[1];
            if (inArea(newX,newY) && board[newX][newY] == 'M') {
                count++;
            }
        }
        if (count > 0) {
            // 规则 3
            board[x][y] = (char)(count + '0');
        }else {
            // 规则 2：如果当前位置没有地雷，将它修改为 B
            board[x][y] = 'B';
            for (int[] direction : directions) {
                int newX = x + direction[0];
                int newY = y + direction[1];
                if (inArea(newX,newY) && board[newX][newY] == 'E') {
                    dfs(board,newX,newY);
                }
            }
        }
    }

    private boolean inArea(int x,int y) {
        return x >= 0 && x < rows &&y >=0 && y<cols;
    }


}

//bfs
class Solution {

    private int[][] directions = {{0,1},{1,0},{0,-1},{-1,0},{1,1},{-1,-1},{1,-1},{-1,1}};
    private int rows;
    private int cols;
    public char[][] updateBoard(char[][] board, int[] click) {
        this.rows = board.length;
        this.cols = board[0].length;

        int x = click[0];
        int y = click[1];
        if (board[x][y] == 'M') {
            // 规则 1
            board[x][y] = 'X';
            return board;
        }
        boolean[][] visited = new boolean[rows][cols];
        visited[x][y] = true;

        Queue<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[]{x,y});
        while(!queue.isEmpty()) {
            int[] point = queue.poll();
            int i = point[0];
            int j = point[1];
            int count = 0;
            for (int[] direction:directions) {
                int newi = i + direction[0];
                int newj = j + direction[1];
                if (inArea(newi,newj) && board[newi][newj] == 'M' ) {
                    count++;
                }

            }
            if (count > 0) {
                board[i][j] = (char)(count +'0');
            }else {
                board[i][j] = 'B';
                for (int[] direction:directions) {
                    int newi = i + direction[0];
                    int newj = j + direction[1];
                    if (inArea(newi,newj) && !visited[newi][newj] &&board[newi][newj] == 'E') {
                        visited[newi][newj] = true;
                        queue.offer(new int[]{newi,newj});
                    }
                }
            }
        }
        return board;
    }


    private boolean inArea(int x,int y) {
        return x >= 0 && x < rows &&y >=0 && y<cols;
    }


}
```

 

## 10贪心算法

### 参考链接

· [coin change 题目](https://leetcode-cn.com/problems/coin-change/)

类似完全背包的思路，硬币数量不限，求凑成总金额所需的最少的硬币个数。

定义 `dp[i][j]` 表示从前 i 种硬币选出总金额为 j 所需的最少硬币数。

由于：

-   `dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - v] + 1, dp[i - 1][j - 2v] + 2, ... , dp[i - 1][j - kv] + k)`
-   `dp[i][j - v] = min( dp[i - 1][j - v], dp[i - 1][j - 2v] + 1, ... , dp[i - 1][j - kv] + k - 1)`

因此 `dp[i][j] = min(dp[i - 1][j], dp[i][j - v] + 1)`。

时间复杂度 `O(m*amount)`，其中 m 表示 coins 长度。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int m = coins.length;
        int[][] dp = new int[m+1][amount+1];
        for (int i = 0; i <= m ; i++) {
            Arrays.fill(dp[i],amount+1);

        }
        dp[0][0] = 0;
        for (int i = 1; i <= m ; i++) {
            int v = coins[i-1];
            for (int j = 0; j <= amount ; j++) {
                dp[i][j] = dp[i-1][j];
                if (j >= v) {
                    dp[i][j] = Math.min(dp[i][j],dp[i][j-v]+1);
                }
            }
        }
        return dp[m][amount] > amount ? -1:dp[m][amount];
    }
}

class Solution {
    public int coinChange(int[] coins, int amount) {
       int[] dp = new int[amount+1];
       Arrays.fill(dp,amount+1);
       dp[0] = 0;
       for (int coin:coins) {
           for (int i = coin; i <= amount; i++) {
               dp[i] = Math.min(dp[i],dp[i-coin]+1);

           }
       }
       return dp[amount] > amount ? -1:dp[amount];
    }
}
```

### 课后作业

· https://leetcode-cn.com/problems/lemonade-change/description/

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int fives = 0,tens = 0;
        for (int bill : bills) {
            if (bill == 5) {
                ++fives;
            }else if (bill == 10) {
                if (fives <= 0) {
                    return false;
                }
                --fives;
                ++tens;
                //++tens;
                //if (--fives < 0) {
                  //  return false;
                //}
            }else {
                if (tens >= 1 && fives >=1) {
                    --tens;
                    --fives;
                }else if (fives >= 3) {
                    fives -= 3;
                }else {
                    return false;
                }
            }
        }
        return true;
    }
}
```

· https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/

动态规划法

设 f1 表示当天结束后持有股票的最大利润，f2 表示当前结束后没有持有股票的最大利润。

初始第 1 天结束时，`f1 = -prices[0]`，`f2 = 0`。

从第 2 天开始，当天结束时：

-   若持有股票，则可能是前一天持有股票，然后继续持有；也可能是前一天没有持有股票，然后当天买入股票。最大利润 `f1 = max(f1, f2 - prices[i])`。
-   若没有持有股票，则可能是前一天没持有股票，今天也没持有股票；或者前一天持有股票，然后今天卖出。最大利润 `f2 = max(f2, f1 + prices[i])`。

最后返回 f2 即可。

```java
//贪心策略
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        for (int i = 1; i < prices.length; i++) {
            // 策略是所有上涨交易日都做买卖，所以下跌交易日都不做买卖
            int t = prices[i] - prices[i-1];
            res += Math.max(t,0);

        }
        return res;
    }
}

//动态规划
class Solution {
    public int maxProfit(int[] prices) {
        int f1 = -prices[0],f2 = 0;
        for (int i = 1;i< prices.length;++i) {
            f1 = Math.max(f1,f2-prices[i]);
            f2 = Math.max(f1+prices[i],f2);
        }

        return f2;
    }
}
```

· https://leetcode-cn.com/problems/assign-cookies/description/

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int child = 0,cookie = 0;
        while( child < g.length && cookie < s.length) {
            if (g[child] <= s[cookie])
                ++child;
            ++cookie;
        }
        return child;
    }
}
```

· https://leetcode-cn.com/problems/walking-robot-simulation/description/

```java
class Solution {
    public int robotSim(int[] commands, int[][] obstacles) {
        int[] direx = {0,1,0,-1};
        int[] direy = {1,0,-1,0};

        int curx = 0,cury = 0;
        int curdire = 0;


        int ans = 0;

        Set<Pair<Integer,Integer>> obstacleSet = new HashSet<>();
        for (int i = 0; i < obstacles.length; i++) {
            obstacleSet.add(new Pair<>(obstacles[i][0],obstacles[i][1]));
        }

        for (int i = 0; i < commands.length; i++) {
            if (commands[i] == -1) {
                curdire=(curdire+1)%4;
            }else if (commands[i] == 2) {
                curdire=(curdire+3)%4;
            }else{
                for (int j = 0; j < commands[i]; j++) {
                    int nx = curx+direx[curdire];
                    int ny = cury+direy[curdire];

                    if (!obstacleSet.contains(new Pair<>(nx,ny))) {
                        curx = nx;
                        cury = ny;
                        ans = Math.max(ans,curx*curx+cury*cury);
                    }else {
                        break;
                    }
                }
            }
        }
        return ans;

    }
}
```

· [https://leetcode-cn.com/problems/jump-game/ ](https://leetcode-cn.com/problems/jump-game/)、

1.如果某一个作为起跳点的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为起跳点
2.可以对每一个能作为 起跳点 的格子都尝试跳一次，把能跳到最远的距离不断更新
3.如果可以一直跳到最后，就成功了

```java
class Solution {
    public boolean canJump(int[] nums) {
        int mx = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i>mx) {
                return false;
            }
            mx = Math.max(mx,i+nums[i]);
        }
        return true;
    }
}
```

[https://leetcode-cn.com/problems/jump-game-ii/](https://leetcode-cn.com/problems/jump-game-ii/)

```java
class Solution {
    public int jump(int[] nums) {
        int steps = 0;
        int end = 0;
        int mx = 0;
        for (int i = 0; i < nums.length; i++) {
            mx = Math.max(mx,nums[i] + i);
            if (i == end) {
                end = mx;
                steps++;
            }
        }
        return steps;
    }
}
```

## 11二分查找

### 参考链接

· 二分查找代码模板

```java
public int binarySearch(int[] array, int target) {
    int left = 0, right = array.length - 1, mid;
    while (left <= right) {
        mid = (right - left) / 2 + left;
 
        if (array[mid] == target) {
            return mid;
        } else if (array[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
 
    return -1;
}
```

· [Fast InvSqrt() 扩展阅读](https://www.beyond3d.com/content/articles/8/)

### 实战题目

· https://leetcode-cn.com/problems/sqrtx/

```java
//二分查找
class Solution {
    public int mySqrt(int x) {
        int left = 0,right = x;

        while(left < right) {
            int mid = (left + right +1) >>> 1;
            if (mid <= x /mid) {
                left = mid;
            }else {
                right = mid - 1;
            }
        }
        return left;
    }

}
```

· https://leetcode-cn.com/problems/valid-perfect-square/

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int left = 0,right = num;
        while (left < right) {
            int mid = (left + right + 1) >>>1;
            if (mid <= num / mid) {
                left = mid;
            }else {
                right = mid - 1;
            }
        }
        return left * left == num;
    }
}
```

### 课后作业

· https://leetcode-cn.com/problems/search-in-rotated-sorted-array/

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int left = 0,right = n-1;
        while(left<right) {
            int mid = (left + right) >> 1;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target <= nums[mid]) {
                    right = mid;
                }else {
                    left = mid + 1;
                }
            }else {
                if (nums[mid] < target && target <= nums[n-1]) {
                    left = mid + 1;
                }else {
                    right = mid;
                }
            }
        }
        return nums[left] == target ? left : -1;
    }
}
```

· https://leetcode-cn.com/problems/search-a-2d-matrix/

```java
//从左下角或右上角搜索：
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        for (int i = m-1,j=0; i >= 0 && j<n ;) {
            if (matrix[i][j] == target ) {
                return true;
            }
            if (matrix[i][j] > target) {
                --i;
            }else {
                ++j;
            }

        }
        return false;
    }
}

//二分查找：
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length,n = matrix[0].length;
        int left = 0,right = m*n - 1;
        while(left < right) {
            int mid = (left + right) >> 1;
            int x = mid / n, y = mid %n;
            if (matrix[x][y] >= target) {
                right = mid;
            }else {
                left = mid + 1;
            }
        }
        return matrix[left / n][right % n] == target;
    }
}
```

· https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/

```java
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length;
        if (nums[0] <= nums[n-1]) {
            return nums[0];
        }
        int left = 0,right = n-1;
        while (left < right) {
            int mid = (left + right) >> 1;
            if (nums[0] < nums[mid]) {
                left = mid + 1;
            }else {
                right = mid;
            }
        }
        return nums[left];
    }
}
```

· 使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方
说明：同学们可以将自己的思路、代码写在第 3 周的学习总结中

 

## 12动态规划

### 参考链接

· 递归代码模板

```java
public void recur(int level,int param) {
    //terminator
    if(level > MAX_LEVEL) {
	//process result
        return;
    }
    
    //process current logic
    process(level,param);
    
    //drill down
    recur(level:level+1,newParam);
    
    //restore current status
}
```



· [分治代码模板](http://shimo.im/docs/3xvghYh3JJPKwdvt/)

```java
private static int divide_conquer(Problem problem,) {
    if(problem == NULL) {
        int res = process_last_result();
        return res;
    }
    subProblems = split_problem(problem);
    
    res0 = divide_conquer(subProblems[0]);
    res1 = divide_conquer(subProblems[1]);
    
    result = process_result(res0,res1);
    return result;
}
```

· [动态规划定义](https://en.wikipedia.org/wiki/Dynamic_programming)

但是经分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。
如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。

```c
int fib(int n) {
    if (n<=0) {
        return 0;
    }else if(n==1) {
        return 1;
    }else {
        return fib(n-1)+fib(n-2);
    }
}

int fib(int n,int[] memo) {
    if ( n<=0) {
        return 0;
    }else if(n==1) {
        return 1;
    }else if(memo[n] == 0) {
        memo[n] = fib(n-1)+fib(n-2);
    }
    return memo[n];
}

int fib(int n,int[] memo) {
    if ( n<=1) {
        return n;
    }
    
    if(memo[n] == 0) {
        memo[n] = fib(n-1)+fib(n-2);
    }
    return memo[n];
}
```

 

 参考链接

· [不同路径题目](https://leetcode-cn.com/problems/unique-paths/)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}


class Solution {
    public int uniquePaths(int m, int n) {
        int[] cur = new int[n];
        Arrays.fill(cur,1);

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                cur[j] += cur[j-1];
            }
        }
        return cur[n-1];
    }
} 

```

· [不同路径 2 题目](https://leetcode-cn.com/problems/unique-paths-ii/)

> 状态转移方程（DP方程）
>
> opt[i,j] = opt[i+1,j] + opt[i,j+1]
>
> 完整逻辑
>
> if a[i,j] = '空地' :
>
> ​	opt[i,j] = opt[i+1,j] + opt[i,j+1]
>
> else:
>
> ​	opt[i,j] = 0

> 动态规划关键点
>
> 1.最优子结构 opt[n] = best_of(opt[n-1],opt[n-2],...)
>
> 2.储存中间状态： opt[i]
>
> 3.递推公式（美其名曰：状态转移方程或者DP方程）
>
> ​	Fib：opt[i] = opt[n-1]+opt[n-2]
>
> ​	二维路径：opt[i,j] = opt[i+1,j]+opt[i,j+1] (且判断a[i,j]是否空地)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int rows = obstacleGrid.length;
        if (rows == 0) {
            return 0;
        }

        int cols = obstacleGrid[0].length;
        int[][] dp = new int[rows][cols];

        for (int i = 0; i < cols; i++) {
            if (obstacleGrid[0][i] == 1) {
                break;
            }
            dp[0][i] = 1;
        }
        for (int i = 0; i < rows; i++) {
            if (obstacleGrid[i][0] == 1) {
                break;
            }
            dp[i][0] = 1;
        }

        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0;
                }else {
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[rows-1][cols-1];
    }
}
```



· [最长公共子序列题目](https://leetcode-cn.com/problems/longest-common-subsequence/)

<img src="F:\LearninginUniversity\2022——自学\笔记\img\屏幕截图 2023-04-30 190316.png" style="zoom:50%;" />

> DP方程
>
> -1 在python中是最后一个字母
>
> if S1[-1] != S2[-1]: LCS[s1,s2] = Max(LCS[s1-1,s2],LCS[s1,s2-1])
>
> if S1[-1] == s2[-1]: LCS[s1,s2] = LCS[s1-1,s2-1]+1

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int s1 = text1.length();
        int s2 = text2.length();
        // dp[i][j]：长度为 i 的 text1 前缀字符串与长度为 j 的 text2 前缀字符串的最长公共子串的长度
        // 字符串的问题需要考虑空串，所以多开一行，多开一列

        int[][] dp = new int[s1+1][s2+1];


        // 由于通过下标访问字符的 charAt() 方法每一次都会去检查下标是否越界
        // 通常，字符串的遍历先将字符串转为字符数组
        char[] charArray1 = text1.toCharArray();
        char[] charArray2 = text2.toCharArray();

        for (int i = 1; i <= s1; i++) {
            for (int j = 1; j <= s2; j++) {
                if (charArray1[i-1] == charArray2[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[s1][s2];

    }
}
```



· [MIT 动态规划课程最短路径算法](https://www.bilibili.com/video/av53233912?from=search&seid=2847395688604491997)

 实战题目

· https://leetcode-cn.com/problems/climbing-stairs/description/

> 思考：
>
> 1. 可以爬1，2，3 f(n) = f(n-1) + f(n-2) + f(n-3)
> 2. 相邻步骤不能相同
>
> 就是说：不能是1，1，1
>
> 

· https://leetcode-cn.com/problems/triangle/description/

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int[] A = new int[triangle.size()+1];

        for (int i = triangle.size()-1; i >= 0; i--) {
            for (int j = 0; j < triangle.get(i).size(); j++) {
                A[j] = Math.min(A[j],A[j+1]) + triangle.get(i).get(j);
            }
        }
        return A[0];
    }
}


```



> 1. brute-force, 递归，n层：left or right : 2^n
> 2. DP
>
> a. 重复性（分治） problem(i,j) = min(sub(i+1,j),sub(i+1,j+1)) + a[i,j]
>
> b. 定义状态数组 
>
> c. DP方程 f(i,j) = min(f[i+1,j],f[i+1,j+1]) + a[i,j]

· https://leetcode.com/problems/triangle/discuss/38735/Python-easy-to-understand-solutions-(top-down-bottom-up)

· https://leetcode-cn.com/problems/maximum-subarray/

> 1. 暴力： n^2
> 2. DP:
>
> a. 分治（子问题） max_sum(i) = Max(max_sum(i-1),0) + a[i]
>
> b. 状态数组定义： f[i]
>
> c. DP方程： f[i] = Max(f[i-1],0) + a[i]

```java
class Solution {
    public int maxSubArray(int[] nums) {
        //dp[i]代表以nums[i]结尾的连续子数组的最大和
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        int res = dp[0];
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(nums[i],nums[i]+dp[i-1]);
            res = Math.max(dp[i],res);
        }
        return res;
    }
}
```

· https://leetcode-cn.com/problems/maximum-product-subarray/description/





### 实战题目

· https://leetcode-cn.com/problems/house-robber/

>  a[i] : 0..i 能偷到 max value ： a[n-1]
>
>  a[i]\[0,1] : 0: 不偷， 1：偷
>
> a[i]\[0] = max(a[i-1]\[0],a[i-1]\[1])
>
> a[i]\[1] = a[i-1]\[0] + nums[i]

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int[][] a = new int[n][2];

        a[0][0] = 0;
        a[0][1] = nums[0];

        for (int i = 1; i < n; i++) {
            a[i][0] = Math.max(a[i-1][0],a[i-1][1]);
            a[i][1] = a[i-1][0] + nums[i];
        }
        return Math.max(a[n-1][0],a[n-1][1]);
    }
}
```

> 简化：
>
> a[i] : 0..i 能偷到 max value：max(a)
>
> a[i]: 0..i天，且nums[i]必偷的最大值
>
> a[i] = max(a[i-1],a[i-2]+nums[i])

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length==1) return nums[0];

        int n = nums.length;
        int[] a = new int[n];

        a[0] = nums[0];
        a[1] = Math.max(nums[0],nums[1]);
        int res = Math.max(a[0],a[1]);
        for (int i = 2; i < n; i++) {
            a[i] = Math.max(a[i-1],a[i-2]+nums[i]);
            res = Math.max(a[i],res);
        }
        return res;
    }
}
```

· https://leetcode-cn.com/problems/house-robber-ii/description/



· [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/#/description](#/description)

· https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/

· https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/

· https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

· https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/

· https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/

· https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/

### 高级 DP 实战题目

· https://leetcode-cn.com/problems/perfect-squares/

· [https://leetcode-cn.com/problems/edit-distance/ ](https://leetcode-cn.com/problems/edit-distance/)（重点）

· https://leetcode-cn.com/problems/jump-game/

· https://leetcode-cn.com/problems/jump-game-ii/

· https://leetcode-cn.com/problems/unique-paths/

· https://leetcode-cn.com/problems/unique-paths-ii/

· https://leetcode-cn.com/problems/unique-paths-iii/

· https://leetcode-cn.com/problems/coin-change/

> 1. brute-force :递归：指数
>
> 2. BFS
>
> 3. DP
>
>    a. subproblems
>
>    b. DP array: f(n) = f(n-1) + f(n-2) + f(n-5)
>
>    f(n) = min{ f(n-k) , for k in [1,2,5]} + 1
>
>    c. DP方程

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount+1;
        int[] dp = new int[max];
        Arrays.fill(dp,max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i],dp[i-coins[j]]+1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

· https://leetcode-cn.com/problems/coin-change-2/

注意：请大家先消化前面的实战题目，高级 DP 的方法和题解会在课程后面解锁。

### 课后作业

· https://leetcode-cn.com/problems/longest-valid-parentheses/

· https://leetcode-cn.com/problems/minimum-path-sum/

· https://leetcode-cn.com/problems/decode-ways

· https://leetcode-cn.com/problems/maximal-square/

· https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/

· https://leetcode-cn.com/problems/frog-jump/

· https://leetcode-cn.com/problems/split-array-largest-sum

· https://leetcode-cn.com/problems/student-attendance-record-ii/

· https://leetcode-cn.com/problems/task-scheduler/

· https://leetcode-cn.com/problems/palindromic-substrings/

· https://leetcode-cn.com/problems/minimum-window-substring/

· https://leetcode-cn.com/problems/burst-balloons/

## 13字典树和并查集

### 参考链接

· [二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

· Tire 树代码模板

> 基本性质
>
> 1. 结点本身不存完整单词
> 2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串
> 3. 每一结点的所有子结点路径代表的字符都不相同

· [实现 Trie](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/)

```java
class Trie {

    class TrieNode {
        private boolean isEnd;
        TrieNode[] next;

        public TrieNode() {
            isEnd = false;
            next = new TrieNode[26];
        }
    }

    private TrieNode root;
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            if (node.next[c-'a'] == null) {
                node.next[c-'a'] = new TrieNode();
            }
            node = node.next[c-'a'];
        }

        node.isEnd = true;
    }

    
    public boolean search(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            node = node.next[c-'a'];
            if (node == null) {
                return false;
            }
        }
        return node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            node = node.next[c-'a'];
            if (node == null) {
                return false;
            }
        }
        return true;
    }
}
```

· https://leetcode-cn.com/problems/word-search-ii/

> 1. words 遍历 --> board search
>
>    O(N\*m\*m\*4^k) m是行和列 4 是四通路 k是单词的长度
>
>
> (-1,0)-上 (1,0)-下 (0,-1)-左 (0,1)-右
>
> 

```java
class Solution {

    private static final int[][] DIRECTIONS = {{-1,0},{0,-1},{1,0},{0,1}};
    private int rows;
    private int cols;
    public List<String> findWords(char[][] board, String[] words) {
        this.rows = board.length;
        this.cols = board[0].length;
        // 第 1 步：插入所有单词
        TrieTree trieTree = new TrieTree();
        for (String word : words) {
            trieTree.insert(word);
        }
        // 第 2 步：深度优先遍历
        List<String> res = new ArrayList<>();
        boolean[][] visited = new boolean[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (trieTree.root.next[board[i][j]-'a'] != null ) {
                    dfs(board,visited,i,j,trieTree.root,res);
                }
            }
        }
        return res;
    }

    private void dfs(char[][] board,boolean[][] visited,int i,int j,TrieNode currNode,List<String> ans) {
        char c = board[i][j];
        currNode = currNode.next[c-'a'];
        if (currNode.val != null) {
            ans.add(currNode.val);
            currNode.val = null;
            // 注意：前缀树这里不能 return; 必须继续搜索
        }
        visited[i][j] = true;
        for (int[] direction : DIRECTIONS) {
            int nexX = i + direction[0];
            int nexY = j + direction[1];
            if (inArea(nexX,nexY) && !visited[nexX][nexY] && currNode.next[board[nexX][nexY]-'a'] != null) {
                dfs(board,visited,nexX,nexY,currNode,ans);
            }
        }
        visited[i][j] = false;
    }

    private boolean inArea(int x,int y) {
        return x >= 0 && x < rows && y>= 0 && y<cols;
    }

    private class TrieNode {
        private String val;
        private TrieNode[] next;

        public TrieNode() {
            next = new TrieNode[26];
        }
    }
    private class TrieTree {
        private TrieNode root = new TrieNode();
        public void insert(String word) {
            TrieNode node = root;

            char[] charArray = word.toCharArray();
            for (char c : charArray) {
                if (node.next[c-'a'] == null) {
                    node.next[c-'a'] = new TrieNode();
                }
                node = node.next[c-'a'];
            }
            node.val = word;
        }
    }
}
```



· 分析单词搜索 2 用 Tire 树方式实现的时间复杂度，请同学们提交在第 6 周的学习总结中。

 参考链接

· [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

· [并查集代码模板](https://shimo.im/docs/ydPCH33xDhK9YwWR)

  ```java
  class UnionFind {
      private int count = 0;
      private int[] parent;
      public UnionFind(int n) {
          count = n;
          parent = new int[n];
          for (int i = 0;i<n;i++) {
              parent[i] = i;
          }
      }
      
      public int find(int p) {
          while(p!=parent[p]) {
              parent[p] = parent[parent[p]];
              p = parent[p];
          }
          return p;
      }
      
      public void union(int p,int q) {
          int rootP = find(p);
          int rootQ = find(q);
          if (rootP == rootQ) return;
          parent[rootP] = rootQ;
          count--;
      }
  }
  ```



### 实战题目 / 课后作业

· https://leetcode-cn.com/problems/friend-circles

> 转化为 岛屿数目
>
> 1. DFS
> 2. BFS
> 3. 并查集 disjoint set
>
>    a. N --> 各自独立集合
>
>    b. 遍历好友关系矩阵 M ： M[i]\[j] --> 合并
>
>    c. 看有多少孤立的集合
>

```java
//DFS
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int[] visited = new int[isConnected.length];
        int count = 0;
        for (int i = 0; i < isConnected.length; i++) {
            if (visited[i] == 0) {
                dfs(isConnected,visited,i);
                count++;
            }
        }
        return count;
    }

    private void dfs(int[][] isConnected, int[] visited, int i) {
        for (int j = 0; j < isConnected.length; j++) {
            if (isConnected[i][j] == 1 && visited[j] ==0) {
                visited[j]=1;
                dfs(isConnected,visited,j);
            }
        }
    }
}
//union-find
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int len = isConnected.length;
        UnionFind unionFind = new UnionFind(len);

        for (int i = 0; i < len; i++) {
            for (int j = 0; j < i; j++) {
                if (isConnected[i][j] == 1) {
                    unionFind.union(i,j);
                }
            }
        }
        return unionFind.count;
    }

    class UnionFind {
        private int count = 0;
        private int[] parent;
        public UnionFind(int n) {
            count = n;
            parent = new int[n];
            for (int i = 0;i<n;i++) {
                parent[i] = i;
            }
        }

        public int find(int p) {
            while(p!=parent[p]) {
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            return p;
        }

        public void union(int p,int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ) return;
            parent[rootP] = rootQ;
            count--;
        }

        public int getCount() {
            return count;
        }

    }
}
```



· https://leetcode-cn.com/problems/number-of-islands/

· https://leetcode-cn.com/problems/surrounded-regions/

## 14高级搜索

### 参考链接

· [AlphaZero Explained](https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/)

· [棋类复杂度](https://en.wikipedia.org/wiki/Game_complexity)

 实战题目

· https://leetcode-cn.com/problems/climbing-stairs/

```java
class Solution {
    public int climbStairs(int n) {

        if (n == 1) return 1;
        if (n == 2) return 2;

        int sum = 0;
        int cur = 2;
        int pre = 1;

        for (int i = 3; i <= n; i++) {
            sum = pre + cur;
            pre = cur;
            cur = sum;
        }
        return sum;
    }
}
```

· https://leetcode-cn.com/problems/generate-parentheses/

```java
class Solution {

    private List<String> result;

    public List<String> generateParenthesis(int n) {
        result = new ArrayList<>();
        dfs(0,0,n,"");
        return result;

    }

    private void dfs(int left, int right, int n, String s) {
        //terminator
        if (left == n && right == n) {
            //filter out the invalid parentheses
            result.add(s);
//            return;
        }

        //process

        //drill down
        if (left < n) {
            dfs(left + 1,right,n,s+"(");
        }

        if (right < n && right < left) {
            dfs(left,right+1,n,s+")");
        }

        //restore
    }

}
```

· [https://leetcode-cn.com/problems/n-queens](https://leetcode-cn.com/problems/n-queens/)

> void backtracking(参数) {
>     if (终止条件) {
>         存放结果;
>         return;
>     }
>     for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
>         处理节点;
>         backtracking(路径，选择列表); // 递归
>         回溯，撤销处理结果
>     }
> }

```java
class Solution {
    private List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        char[][] chessBoard = new char[n][n];
        for (char[] c : chessBoard) {
            Arrays.fill(c,'.');
        }
        backTrack(n,0,chessBoard);
        return res;

    }

    private void backTrack(int n, int row, char[][] chessBoard) {
        if (row == n) {
            res.add(Array2List(chessBoard));
        }

        for (int col = 0; col < n; col++) {
            if (isValid(row,col,n,chessBoard)) {
                chessBoard[row][col] = 'Q';
                backTrack(n,row+1,chessBoard);
                chessBoard[row][col] = '.';
            }
        }
    }

    private boolean isValid(int row, int col, int n, char[][] chessBoard) {
        for (int i = 0; i < row; i++) {
            if (chessBoard[i][col] == 'Q') {
                return false;
            }
        }

        for (int i = row-1,j=col-1; i>=0 && j>=0 ; i--,j--) {
            if (chessBoard[i][j] == 'Q') {
                return false;
            }
        }

        for (int i = row-1,j=col+1; i >= 0 && j <= n-1 ; i--,j++) {
            if (chessBoard[i][j] == 'Q') {
                return false;
            }
        }

        return true;
    }

    private List<String> Array2List(char[][] chessBoard) {
        List<String> list = new ArrayList<>();

        for (char[] c : chessBoard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }

}
```

· https://leetcode-cn.com/problems/valid-sudoku/description/

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        HashMap[] row = new HashMap[9];
        HashMap[] column = new HashMap[9];
        HashMap[] box = new HashMap[9];
        for (int i = 0; i < 9; i++) {
            row[i] = new HashMap(9);
            column[i] = new HashMap(9);
            box[i] = new HashMap(9);
        }
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') {
                    continue;
                }
                int boxIndex=i / 3 * 3 + j / 3;
                if ((boolean) row[i].getOrDefault(board[i][j], false)) {
                    return false;
                }
                if ((boolean) column[j].getOrDefault(board[i][j], false)) {
                    return false;
                }
                if ((boolean) box[boxIndex].getOrDefault(board[i][j], false)) {
                    return false;
                }
                row[i].put(board[i][j], true);
                column[j].put(board[i][j], true);
                box[boxIndex].put(board[i][j], true);
            }
        }

        return true;
    }
}
```

· [https://leetcode-cn.com/problems/sudoku-solver/#/description](#/description)

```java
class Solution {
    public void solveSudoku(char[][] board) {
        if (board == null && board.length==0) {
            return;
        }
        solve(board);
    }

    public boolean solve(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == '.') {
                    for (char c = '1';c <= '9';c++) {//trial try 1 through 9
                        if (isValid(board,i,j,c)) {
                            board[i][j]=c;
                            if (solve(board)) {
                                return true;//if it's the solution return true
                            } else {
                                board[i][j] = '.';//otherwise go back
                            }
                        }

                    }
                    return false;
                }
            }
        }
        return true;
    }

    private boolean isValid(char[][] board,int row,int col,char c) {
        for (int i = 0; i < 9; i++) {
            if (board[i][col] != '.' && board[i][col] == c) return false; //check row
            if (board[row][i] != '.' && board[row][i] == c) return false; //check col
            if (board[3*(row/3)+i/3][3*(col/3)+i%3] != '.' && board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;//check 3*3 block

        }
        return true;
    }
}

//2

```

 实战题目

· https://leetcode-cn.com/problems/word-ladder/

```java
//BFS
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        HashSet<String> wordSet = new HashSet<>(wordList);

        if (wordSet.size() == 0 || wordSet.isEmpty()) {
            return 0;
        }

        wordSet.remove(beginWord);

        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);

        int step = 1;
        while (!queue.isEmpty()) {
            int currentSize = queue.size();
            for (int i = 0; i < currentSize; i++) {
                String currentWord = queue.poll();
                if (changeWordOneLetter(currentWord,endWord,queue,visited,wordSet)) {
                    return step+1;
                }
            }
            step++;
        }
        return 0;
    }

        private boolean changeWordOneLetter(String currentWord, String endWord,
                                            Queue<String> queue, Set<String> visited, Set<String> wordSet) {

            char[] charArray = currentWord.toCharArray();

            for (int i = 0; i < endWord.length(); i++) {
                char originChar = charArray[i];
                for (char j = 'a'; j <= 'z';j++) {
                    if (j == originChar) {
                        continue;
                    }
                    charArray[i] = j;

                    String nextWord = String.valueOf(charArray);
                    if (wordSet.contains(nextWord)) {
                        if (nextWord.equals(endWord)) {
                            return true;
                        }
                        if (!visited.contains(nextWord)) {
                            queue.add(nextWord);
                            visited.add(nextWord);
                        }
                    }
                }
                // 恢复
                charArray[i] = originChar;
            }
            return false;
        }
    }

//two-end BFS
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> wordSet = new HashSet<>(wordList);
        if (wordSet.size() == 0 || !wordSet.contains(endWord)) {
            return 0;
        }

        Set<String> visited = new HashSet<>();

        Set<String> beginVisited = new HashSet<>();
        beginVisited.add(beginWord);
        Set<String> endVisited = new HashSet<>();
        endVisited.add(endWord);

        int step = 1;
        while (!beginVisited.isEmpty() && !endVisited.isEmpty()) {
            if (beginVisited.size() > endVisited.size()) {
                Set<String> temp = beginVisited;
                beginVisited = endVisited;
                endVisited = temp;
            }

            // 逻辑到这里，保证 beginVisited 是相对较小的集合，nextLevelVisited 在扩散完成以后，会成为新的 beginVisited
            Set<String> nextLevelVisited = new HashSet<>();

            for (String word : beginVisited) {
                if (changeWordOneLetter(word,endVisited,visited,wordSet,nextLevelVisited)) {
                    return step+1;
                }
            }

            beginVisited = nextLevelVisited;
            step++;
        }
        return 0;
    }
        private boolean changeWordOneLetter(String word, Set<String> endVisited,
                                            Set<String> visited, Set<String> wordSet,
                                            Set<String> nextLevelVisited) {

            char[] charArray = word.toCharArray();

            for (int i = 0; i < word.length(); i++) {
                char originChar = charArray[i];

                for (char c = 'a';c <= 'z';c++) {
                    if (originChar == c) {
                        continue;
                    }
                    charArray[i] = c;
                    String nextword = String.valueOf(charArray);
                    if (wordSet.contains(nextword)) {
                        if (endVisited.contains(nextword)) {
                            return true;
                        }

                        if (!visited.contains(nextword)) {
                            nextLevelVisited.add(nextword);
                            visited.add(nextword);
                        }
                    }
                }
                charArray[i] = originChar;
            }
            return false;
        }
    }
```

· https://leetcode-cn.com/problems/minimum-genetic-mutation/

### 课后作业

· 总结双向 BFS 代码模版，请同学们提交在第 6 周学习总结中。



 参考链接

· A* 代码模板

```python
def AstarSearch(graph,start,end);
	pq = collections.priority_queue() #优先级————>估价函数 pq priority queue
    pq.append([start])
    visited.add(start)
    while pq :
        node = pq.pop() # can we add more intelligence here?
        visited.add(node)
        
        process(node)
        nodes = generated_related_nodes(node)
        unvisited = [node for node in nodes if node not in visited]
        pq.push(unvisited)
```

· [相似度测量方法](https://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/)

· [二进制矩阵中的最短路径的 A* 解法](https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313347/A*-search-in-Python)

· [8 puzzles 解法比较](https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/)

### 实战题目

> dp
>
> BFS
>
> A*

· https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/

· https://leetcode-cn.com/problems/sliding-puzzle/

· https://leetcode-cn.com/problems/sudoku-solver/

 

## 15红黑树和AVL树

### 参考链接

· [平衡树](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)

## 16位运算

### 参考链接

· [如何从十进制转换为二进制](https://zh.wikihow.com/从十进制转换为二进制)

 参考链接

· [N 皇后位运算代码示例](https://shimo.im/docs/rHTyt8hcpT6D9Tj8/)

```python
# Python
def totalNQueens(self, n): 	
    if n < 1: return [] 	
    self.count = 0 	
    self.DFS(n, 0, 0, 0, 0) 	
    return self.count
def DFS(self, n, row, cols, pie, na): 	
    # recursion terminator 	
    if row >= n: 		
        self.count += 1 		
        return	
    bits = (~(cols | pie | na)) & ((1 << n) — 1)  # 得到当前所有的空位	
    while bits: 		
        p = bits & —bits # 取到最低位的1		
        bits = bits & (bits — 1) # 表示在p位置上放入皇后		
        self.DFS(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1)         
        # 不需要revert  cols, pie, na 的状态
        
        
# 附带非位运算判重（Python）
def solveNQueens(self, n):  
    def DFS(queens, xy_dif, xy_sum):    
        p = len(queens)    
        if p==n:        
            result.append(queens)       
            return None    
        for q in range(n):        
            if q not in queens and p-q not in xy_dif and \         
            p+q not in xy_sum:             
                DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])    
    result = []  
    DFS([],[],[])  
    return [ ["."*i + "Q" + "."*(n-i-1) for i in sol] for sol in result]
```

```java
class Solution {	
    private int size; 	
    private int count;	
    private void solve(int row, int ld, int rd) { 		
        if (row == size) { 			
            count++; 			
            return; 		
        }		
        int pos = size & (~(row | ld | rd)); 		
        while (pos != 0) { 			
            int p = pos & (-pos); 			
            pos -= p; // pos &= pos - 1; 			
            solve(row | p, (ld | p) << 1, (rd | p) >> 1); 		
        } 	
    } 
    public int totalNQueens(int n) { 	
        count = 0; 	
        size = (1 << n) - 1; 	
        solve(0, 0, 0); 	
        return count;   
    } 
}
```

```c++

class Solution {
public:    
    int totalNQueens(int n) {        
        dfs(n, 0, 0, 0, 0);                
        return this->res;    
    }        
    void dfs(int n, int row, int col, int ld, int rd) {        
        if (row >= n) { res++; return; }                                                 		// 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历        
                                                                                         		int bits = ~(col | ld | rd) & ((1 << n) - 1);        
       while (bits > 0) {            
            int pick = bits & -bits; 
            // 注: x & -x            
 			dfs(n, row + 1, col | pick, (ld | pick) << 1, (rd | pick) >> 1);           
            bits &= bits - 1; // 注: x & (x - 1)        
        }    
    }
private:    
    int res = 0;
};
```

> 异或：相同为0，不同为1.也可用“不进位加法”
>
> & ：相同为1，相异为0
>
> | ：一真则真
>
> x^0=x
>
> x ^ 1s = ~x         //注意1s = ~0
>
> x^(~x)=1s
>
> x^x=0
>
> c = a^b => a^c=b,b^c =a //交换两个数
>
> a^b^c=a^(b^c)=(a^b)^c //associative
>
> =======================================================================
>
> 1.将x最右边的n位清零: x&(~0<< n)
>
> 2.获取x的第n位值(0或者1):(x>>n)&1
>
> 3.获取x的第n位的幂值: x&(1 << (n-1))
>
> 4.仅将第n位置为1: x|(1 << n)
>
> 5.仅将第n位置为0: x&(~(1 << n))
>
> 6.将x最高位至第n位(含)清零: x&((1 << n)-1)
>
> 7.将第n位至第0位(含)清零: x&(~((1 << (n+ 1))-1))
>
> ============================================================================
>
> - 判断奇偶:
>
>   x%2==1 ->(x&1)==1
>
>   x%2==0 ->(x&1)==0
>
>   
>
> - x>>1- >x/ 2
>
>   即:
>
>   x=x/ 2;一> X=X>> 1;
>
>   mid =(left + right)/ 2;  ——>mid =(left +right)>> 1;
>
> - X=X&(X-1)清零最低位的1
>
> - X&-X =>得到最低位的1
>
> - X&~X=>0



### 实战题目 / 课后作业

> #1.forloop:0-->32
> #2.%2，/2
> #3.&1, x=x>>1;(32)
> #4.while(x>0){ 	count++;	x=x&(x-1); 	}

· https://leetcode-cn.com/problems/number-of-1-bits/

> class Solution(object):
> 	def isPowerOfTwo(self, n):
> 		return n != 0 and (n &(n-1))== 0

· https://leetcode-cn.com/problems/power-of-two/

· https://leetcode-cn.com/problems/reverse-bits/

· https://leetcode-cn.com/problems/n-queens/description/

· https://leetcode-cn.com/problems/n-queens-ii/description/





· https://leetcode-cn.com/problems/counting-bits/description/

 ```c++
 vector<int> countBits (int num) {
 	vector<int> bits (num+ 1 ,0) ;
 	for(int i=1;i<=num;i++){
 		bits[i] += bits[i&(i-1)]+1;
 	}
 	return bits;
 }
 ```



## 17布隆过滤器和LRU缓存

### 参考链接

· [布隆过滤器的原理和实现](https://www.cnblogs.com/cpselvis/p/6265825.html)

· [使用布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重](https://blog.csdn.net/tianyaleixiaowu/article/details/74721877)

· [布隆过滤器 Python 代码示例](https://shimo.im/docs/xKwrcwrDxRv3QpKG/)

```python
from bitarray import bitarray
import mmh3

class BloomFilter :
def _init_ (self, size, hash_num) :
    self.size = size
    self.hash_num = hash_num
    self.bit_array = bitarray(size)
    self.bit_array.setall(0)
def add (self, s) :
	for seed in range (self.hash_num) :
        result = mmh3.hash(s,seed)% self.size
		self.bit array[result] = 1
	def lookup (sel f,s) :
		for seed in range (self.hash_num) :
			result = mmh3 。hash(s，seed) 号self. size
			if self .bit array[result] == 0 :
				return "Nope”
			return "Probably"
bf = BloomFilter (500000，7)
bf.add("dantezhao")
print (bf.lookup ("dantezhao") )
print (bf.lookup("yyj") )

```



· [布隆过滤器 Python 实现示例](https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/)

· [高性能布隆过滤器 Python 实现示例](https://github.com/jhgg/pybloof)

· [布隆过滤器 Java 实现示例 1](https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java)

· [布隆过滤器 Java 实现示例 2](https://github.com/Baqend/Orestes-Bloomfilter)

 参考链接

· [Understanding the Meltdown exploit](https://www.sqlpassion.at/archive/2018/01/06/understanding-the-meltdown-exploit-in-my-own-simple-words/)

· [替换算法总揽](https://en.wikipedia.org/wiki/Cache_replacement_policies)

> 两个要素:大小、替换策略
> Hash Table + Double LinkedList
> O(1)查询
> O(1)修改、更新

· [LRU Cache Python 代码示例](https://shimo.im/docs/tTxRkGwJpXG6WkGY/)



### 实战题目 / 课后作业

· [https://leetcode-cn.com/problems/lru-cache/#/](#/)

 ```python
 class LRUCache (object) :
 	def _init_(self, capacity) :
 		self.dic = collections.OrderedDict ()
 		self.remain = capacity
 def	get (self, key) :
 	if key not in self.dic:
 		return - 1
 	V = self.dic.pop(key)
 	self .dic[key] = V # key as the newest one
 	return V
 def put (self， key, value) :
 	if key in self.dic:
 		self.dic.pop(key)
 	else :
 		if self.remain>0:
 			sel.remain -= 1
 		else: #self.dicisfu11
 			self.dic.popitem(last= False)
 	self.dic[key] = value
 
 ```

```java
public class LRUCache{
	private Map< Integer, Integer> map ;
	public LRUCache (int capacity) {
		map=new LinkedCappedHashMap<> (capacity) ;
    }
	public int get (int key) {
        if ( ! map . containsKey (key) ) { return -1; }
		return map.get (key) ;
    }

	public void put (int key, int value) {
		map.put (key, value) ;
    }
	private static class LinkedCappedHashMap< K, V> extends LinkedHashMap< K,V> {
		int maximumCapacity;
		LinkedCappedHashMap (int max imumCapacity) {
			super (16，0.75f ,true) ;
			this . max imumCapacity = max imumCapacity ;
		}
		protected boolean removeEldestEntry (Map. Entry eldest){
			return size()>maximumCapacity;
        }
    }
}

```



## 18排序算法

![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\PotPlayerMini64_TiMI6XigtB.png)



### 参考链接

· [十大经典排序算法](https://www.cnblogs.com/onepixel/p/7674659.html)

· [快速排序代码示例](https://shimo.im/docs/98KjvGwwGpTpYGKy/)

```java
public static void quickSort (int [] array, int begin, int end)	{
	if(end <= begin)	return ;
	int pivot = partition (array, begin,end) ;
	quickSort (array, begin, pivot-1) ;
	quickSort (array, pivot + 1 ，end) ;
}
static int partition (int[] a,int begin,int end) {
// pivot: 标杆位置，counter: 小于pivot的元素的个数
	int pivot = end, counter = begin;
	for(int i=begin;i<end;i++){
		if(a[i]<a[pivot]){
			int temp = a[counter] ; 
            a[counter]=a[i]; 
            a[i] = temp;
			counter++ ;
		}
		int temp= a[pivot] ; 
        a[pivot] = a[counter]; 
        a[counter] = temp;
		return counter ;

```



· [归并排序代码示例](https://shimo.im/docs/YqgG6vtdKwkXJkWx/)

```java
public static void mergeSort (int [ ] array, int left, int right) {
	if ( right <= left )return ;
	int mid = (left + right) >> 1; // (left + right) / 2
	mergeSort (array, left,mid) ;
	mergeSort (array, mid + 1,right) ;
	merge (array, left， mid, right) ;
}

public static void merge (int[] arr, int left， int mid, int right) {
	int[] temp=newint[right - left+1]; //中间数组
	int i=left，j=mid+1，k=0;
    
	while (i <= mid && j <= right) {
		temp[k++] = arr [i] <= arr[j] ? arr [ i++] : arr [j++] ;
	}
	while(i<=mid)	temp[k++]=arr[i++];
	while(j<=right)	temp[k++]=arr[j++];
	for (int p = 0; p < temp. length; p++) {
		arr[left + p]= temp[p];
    } 
	//也可以用System.arraycopy (a, startl, b, start2， length)
}

```



· [堆排序代码示例](https://shimo.im/docs/6kRVHRphpgjHgCtx/)

```c++
void heap sort (int a[]，int len) {
	priority queue <int, vector<int>，greater<int> > q;
		for (int i =0;i<len;i++){
			q.push(a[i]) ;
        }
		for(int i=0;i<len;i++){
			a[i] = q.pop() ;
        }
}
```

```java
static void heapify (int[] array, int length, int i) {
	int left=2*i+1,right=2*i+2;
	int largest = i;
    
	if (left < length && array[left] > array[largest]) {
		largest = leftChi ld;
    }
	if (right < length && array[right] > array[largest]) {
		largest=right;
    }
	if (largest != i) {
		int temp = array[i] ; array[i] = array[largest] ; array[ largest] = temp ;
		heapify (array, length, largest) ;
	}
    
public static void heapSort (int [] array) {
	if (array. length == 0)	return;
	int length = array.length;
	for(int i=length/2-1;i>=0;i--) {
        heapify (array,length, i) ;
    }

	for(inti=length-1;i>=0;i--){
        int temp = array [0] ; array[0] = array [i] ; array[i] = temp;
		heapify (array, i,0) ;
    }
}

```



· 直播课回顾: [https://pan.baidu.com/s/1sFuZ8GjDCXy5mPCNLZhHxw ](https://pan.baidu.com/s/1sFuZ8GjDCXy5mPCNLZhHxw)提取码: 2rdy

### 课后作业

用自己熟悉的编程语言，手写各种初级排序代码，提交到第 7 周学习总结中。

 

### 参考链接

· [十大经典排序算法](https://www.cnblogs.com/onepixel/p/7674659.html)

· [9 种经典排序算法可视化动画](https://www.bilibili.com/video/av25136272)

· [6 分钟看完 15 种排序算法动画展示](https://www.bilibili.com/video/av63851336)

### 实战题目 / 课后作业

· https://leetcode-cn.com/problems/relative-sort-array/

· https://leetcode-cn.com/problems/valid-anagram/

· https://leetcode-cn.com/problems/design-a-leaderboard/

· https://leetcode-cn.com/problems/merge-intervals/

> // 1.暴力法:两个嵌套循环: 0(n^2)
> // 2. merge-sort
> //3. 树状数组

· https://leetcode-cn.com/problems/reverse-pairs/

 ```java
 public class Solution {
     public int revesePairs(int[] nums) {
         return mergeSort(nums,0,nums.length-1);
     }
     
     private int mergeSort(int[] nums,int s,int e) {
         if(s>e) return 0;
         int mid = s+(e-s)/2;
         int cnt = mergeSort(nums,s,mid)+mergeSort(nums,mid+1,e);
         for(int i = s,j=mid+1;i<=mid;i++) {
             while(j<=e && nums[i]/2.0>nums[j]) j++;
             cnt += j-(mid+1);
         }
         Arrays.sort(nums,s,e+1);
         return cnt;
     }
 }
 
 //
 public class Solution {
 	public int reversePairs(int[] nums) {
 		if (nums == null|| nums.length == 0) return 0;
 		return mergeSort(nums， 0，nums.length - 1);
 	}
 	private int mergeSort(int[] nums， int l，int r) {
 		if (l >= r) return 0;
 		int mid=l+(r-l)/2;
 		int count = mergeSort(nums，l，mid) + mergeSort(nums， mid + 1，r);
 		int[]	cache=new int[r-l+1];
 		int i = l, t =l，c=0;
 		for(int j=mid+1;j<=r;j++,c++){
 			while (i <= mid && nums[i] <= 2 * (long)nums[j]) i++;
 			while (t <= mid && nums[t] < nums[j]) cache[C++] = nums[t++];
 			cache[c] = nums[j ] ;
 			count+=mid-i+1;
         }
 		while (t <= mid) cache[c++] = nums [t++];
 		System.arraycopy(cache, 0，nums，l, r-l + 1);
 		return count;
 	}
 }
 ```



## 19高级动态规划

> 动态规划
>
> 1. "Simplifying a complicated problem by breaking
> it down into simpler sub-problems" (in a recursive manner)
> 2. Divide & Conquer + Optimal substructure
> 分治+最优子结构
> 3. 顺推形式:动态递推

```python
function DP():
	dp=[][]#二维情况
	for i=0.. M {
		for j=0.. N {
			dp[i][j]= _Function(dp[i'][j']...);
         }
    }
return dp[M][N];

```



### 参考链接

![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\爬楼梯.png)

· [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\不同路径.png)

作业：有石头时状态方程怎么写

· [不同路径](https://leetcode-cn.com/problems/unique-paths/)

![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\打家劫舍.png)

· [打家劫舍](https://leetcode-cn.com/problems/house-robber/)

![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\最小路径和.png)

· [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\股票买卖.png)

![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\股票买卖_2.png)

· [股票买卖](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

作业：6道股票买卖

### 课后作业

在第 8 周学习总结中，写出[不同路径 2 ](https://leetcode-cn.com/problems/unique-paths-ii/)这道题目的状态转移方程。

 参考链接

> - 1、2、3
> - x1, x2,... x<sub>m</sub>步
> - 前后不能走相同的步伐

```java
class Solution {
    public int climbStairs(int n) {
        if(n <= 1) {
            return n;
        }
        int[] a = new it[n];
        a[0] = 0;
        a[1] = 1;
        for(int i = 2;i < n; i++) {
            a[i] = a[i-1]+a[i-2]+a[i-3];
        }
        return a[n-1];
    }
}

//
for(int i = 2;i < n; i++) {
    for (int j = 0;j<m;j++) {
        a[i] += a[i-x[j]];
    } 
}
//
for(int i = 2;i < n; i++) {
    for (int j = 0;j<m;j++) {
        for(int k =0;k<m;k++) {
            
        }
    }
}
```

· [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

· [使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

> 1.BFS 双端BFS
>
> 2.DP
>
> dp\[i][j]  //word1.substring(0,i) word2.substr(0,j) 之间的编辑距离
>
> ==================================================================
>
> ●如果word1[i]与word2[j]相同，显然dp\[i][j]=dp\[i-1][j-1]
> ●如果word1[i]与word2[j]不同，那么dp\[i][j]可以通过
> 1.在dp\[i- 1][j-1]的基础，上做replace操作达到目的
> 2.在dp\[i- 1][j]的基础上做insert操作达到目的
> 3.在dp\[i][j-1]的基础，上做delete操作达到目的
> 取三者最小情况即可



![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\编辑距离.png)

· [编辑距离](https://leetcode-cn.com/problems/edit-distance/)

### 课后作业

· https://leetcode-cn.com/problems/longest-increasing-subsequence/

· https://leetcode-cn.com/problems/decode-ways/

· https://leetcode-cn.com/problems/longest-valid-parentheses/

· https://leetcode-cn.com/problems/maximal-rectangle/

· https://leetcode-cn.com/problems/distinct-subsequences/

· https://leetcode-cn.com/problems/race-car/

 

## 20字符串算法



### 参考链接

· [不可变字符串](https://lemire.me/blog/2017/07/07/are-your-strings-immutable/)

· Atoi 代码示例

### 字符串基础问题

· https://leetcode-cn.com/problems/to-lower-case/

· https://leetcode-cn.com/problems/length-of-last-word/

· https://leetcode-cn.com/problems/jewels-and-stones/

· https://leetcode-cn.com/problems/first-unique-character-in-a-string/

```java
class Solution {
    public int firstUniqChar(String s) {
        HashMap<Charcter,INteger> hm = new HashMap();
        for(int i= 0;i<s.length();i++) {
            hm.put(s.chatAt(i),hm.getOrDefault(s.chatAt(i),0)+1);
        }
        for (int i= 0;i<s.length();i++) {
            if(hm.get(s.chatAt(i))==1) {
                return i;
            }
        }
        return -1;
    }
}
```



· https://leetcode-cn.com/problems/string-to-integer-atoi/

```java
public int myAtoi(String str) {
    int index= 0,sign=1,total=0;
    if(str.length==0) {
        return 0;
    }
    //remove spaces
    while(str.chatAt(index) == ' ' && index<str.length()) {
        index++;
    }
    //handle signs
    if(str.chatAt(index)=='+' || str.charAt(idnex)=='-') {
        sign = str.chatAt(index) == '+'?1:-1; 
        index++;
    }
    //convert number and avoid overflow
    while(index < str.length()) {
        int digit = str.chatAt(index) - '0';
        if(digit<0 || digit > 9) break;
        
        //check if total will be overflow after 10 times and add digit
        if(Integer.MAX_VALUE/10 < total || Integer.MAX_VALUE/10 && Integer.MAX_VALUE %10 <digit )
            return sign == 1?Integer.MAX_VALUE : Integer.MIN_VALUE;
        total = 10*total+digit;
        index++;
    }
    return total*sign;
    
}
```

### 字符串操作问题

> 1.纯暴力
> 2.
> flower
> flow
> flight
>
> 3.Trie

· https://leetcode-cn.com/problems/longest-common-prefix/description/

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs == null || strs.length == 0 ) return "";
        
        for(int i= 0;i < strs[0].length;i++) {
            char c = strs[0].charAt(i);
            for(int j = 1;j<strs.length;j++) {
                if(i==strs[j].length() || strs.charAt(i) != c) {
                    return strs[0].substring(0,i);
                }
            }
            return strs[0];
        }
    }
}
```

· https://leetcode-cn.com/problems/reverse-string

```java
class Soultion {
    public void reverseString(char[] s) {
        if(s == null) return;
        
        for(int i = 0,j = s.length-1;i<j;i++,j--) {
            char tmp = s[i];
            s[i] = s[j];
            s[j] = tmp;
        }
    }
}
```

> for(int i = 0; i< a.length-1;i++)
>
> ​	for(int j = i+1;j<a.length;j++)
>
> 要熟练

· https://leetcode-cn.com/problems/reverse-string-ii/

· https://leetcode-cn.com/problems/reverse-words-in-a-string/

```java
class Solution {
    public String reveseWords(String s) {
        String[] words = s.trim().split(" +");
        Collections.revese(Arrays.asList(words));
        return String.join(" ",words);
    }
}
```

· https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/

· https://leetcode-cn.com/problems/reverse-only-letters/

### 异位词问题

· https://leetcode-cn.com/problems/valid-anagram/

· https://leetcode-cn.com/problems/group-anagrams/

· https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/

### 回文串问题

· https://leetcode-cn.com/problems/valid-palindrome/

· https://leetcode-cn.com/problems/valid-palindrome-ii/

· https://leetcode-cn.com/problems/longest-palindromic-substring/

```java
//Solution-1 超时
class Solution {
    public String longestPalindrome(String s) {
        int maxPalinLength = 0;
        String longestPalindrome = null;
        int length = s.length();


        for (int i = 0; i < length; i++) {
            for (int j = i+1; j < length; j++) {
                int len = j - i;
                String curr = s.substring(i,j+1);
                if (isPalindrome(curr)) {
                    if (len > maxPalinLength) {
                        longestPalindrome = curr;
                        maxPalinLength = len;
                    }
                }

            }
        }
        if (longestPalindrome == null) {
            longestPalindrome = s.substring(0,1);
        }
        return longestPalindrome;
    }

    private boolean isPalindrome(String curr) {
        for (int i = 0; i < curr.length(); i++) {
            if (curr.charAt(i) != curr.charAt(curr.length() - 1 - i)) {
                return false;
            }
        }
        return true;
    }
}

//Solution-2
class Solution {
    public String longestPalindrome(String s) {

        if (s == null) {
            return null;
        }

        if (s.length() <= 1) {
            return s;
        }

        int maxPalinLength = 0;
        String longestPalindrome = null;
        int length = s.length();

        int[][] table = new int[length][length];

        //every single letter is palindrome
        for (int i = 0; i < length; i++) {
            table[i][i] = 1;
        }

        //e.g. bcba
        //two consecutive same letters are palindrome
        for (int i = 0; i <= length-2; i++) {
            if (s.charAt(i) == s.charAt(i+1)) {
                table[i][i+1] = 1;
                longestPalindrome = s.substring(i,i+2);
            }

        }

        //condition for calculate whole table
        for (int l = 3; l <= length; l++) {
            for (int i = 0; i <= length-l; i++) {
                int j = i+l-1;
                if (s.charAt(i) == s.charAt(j)) {
                    table[i][j] = table[i+1][j-1];
                    if (table[i][j] == 1 && l > maxPalinLength){
                        longestPalindrome = s.substring(i,j+1);
                    }
                }else {
                    table[i][j] = 0;
                }
            }

        }
        if (longestPalindrome == null) {
            longestPalindrome = s.substring(0,1);
        }
        return longestPalindrome;
    }

}
//simple algorithm
class Solution {
    public String longestPalindrome(String s) {

        if (s == null) {
            return null;
        }

        if (s.length() <= 1) {
            return s;
        }

        String longestPalindrome = s.substring(0,1);
        for (int i = 0; i < s.length(); i++) {
            //get longest palindrome with center of i
            String temp = helper(s,i,i);
            if (temp.length() > longestPalindrome.length()) {
                longestPalindrome = temp;
            }

            //get longest palindrom with center of i, i+1
            temp = helper(s,i,i+1);
            if (temp.length()>longestPalindrome.length()) {
                longestPalindrome = temp;
            }
        }

        return longestPalindrome;
    }

    private String helper(String s, int begin, int end) {
        while (begin >= 0 && end <= s.length()-1 && s.charAt(begin) == s.charAt(end)) {
            begin--;
            end++;
        }
        return s.substring(begin + 1,end);
    }

}

//中间向两边扩张法
public class Solution {
    private int lo ,maxLen;
    
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        
        for (int i = 0; i< len-1;i++) {
            extendPalindrome(s,i,i); //odd length
            extendpalindrome(s,i,i+1); //even length
        }
        return s.substring(lo,lo+maxLen);
    }
    
    private void extendPalindrome(String s,int j,int k) {
        while(j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {
            j--;
            k++;
        }
        
        if(maxLen < k-j-1) {
            lo = j+1;
            maxLen = k-j-1;
        }
    }
}

//DP
class Solution {
    public String longestPalindrome(String s ){
        int n = s.length();
        String res = "";
        boolean[][] dp = new boolean[n][n];
        for(int i = n-1;i>= 0;i--) {
            for(int j = i;j<n;j++) {
                dp[i][j] = s.charAt(i) == s.charAt(j) && (j-i<2 || dp[i+1][j-1]);
                
                if(dp[i][j] && j-i+1>res.length()) {
                    res = s.substring(i,j+1);
                }
            }
        }
        return res;
    }
}
```



### 最长子串、子序列问题

> 最长子序列
>
> dp\[i][j] = dp\[i-1][j-1]+1 (if s1[i-1] == s2.[j-1])
>
> else dp\[i][j] = max(dp\[i-1][j],dp\[i][j-1])
>
> ==================================================
>
> 最长子串
>
> dp\[i][j] = dp\[i-1][j-1]+1 (if s1[i-1] == s2.[j-1])
>
> else dp\[i][j] = 0



· https://leetcode-cn.com/problems/longest-common-subsequence/

· https://leetcode-cn.com/problems/edit-distance/

![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\最长回文子串.png)

· https://leetcode-cn.com/problems/longest-palindromic-substring/

### 字符串 +DP 问题

> 

· https://leetcode-cn.com/problems/regular-expression-matching/

```java
class Solution {
    public boolean isMatch(String s,String p) {
        if(p == null || p.length() == 0) return (s == null || s.length() == 0);
        
        boolean dp[][] = new boolean[s.length()+1][p.length()+1];
        dp[0][0] = true;
        
        for(int j=2;j<=p.length();j++) {
            dp[0][j] = p.cahrAt(j-1) == '*' && dp[0][j-2];
        }
        
        for(int j =1;j<= p.length();j++) {
            for(int i = 1;i<= s.length();i++) {
                if(p.charAt(j-1) == s.charAt(i-1) || p.charAt(j-1) == '.')
                    dp[i][j] = dp[i-1][j-1];
                else if(p.charAt(j-1) == '*')
                    dp[i][j] = dp[i][j-2] || ((s.charAt(i-1) == p.charAt(j-2) ||
                                             p.charAt(j-2) == '.') && dp[i-1][j]);
            }
        }
        return dp[s.length()][p.length()];
    }
}
```



· https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/

· https://leetcode-cn.com/problems/wildcard-matching/

![](F:\LearninginUniversity\2022——自学\笔记\img\2023-08\不同子序列.png)

· https://leetcode-cn.com/problems/distinct-subsequences/

 ```java
 class Solution {
     
    public int numDistinct(String s,String t) {
        int[][] dp =new int[t.length()+1][s.length()+1];
        
        for(int i = 0;i<s.length()+1;i++)
            dp[0][i] = 1;
        for(int i=1;i<t.length()+1;i++){
            for(int j = i;j<s.length()+1;j++) {
                if(t.charAt(i-1) == s.charAt(j-1)) {
                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1];
                }else {
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
        return dp[t.length()][s.length()];
    }
 }
 ```





### 参考链接

· [Boyer-Moore 算法](http://xn--https-ni33a//www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)

· [Sunday 算法](https://blog.csdn.net/u012505432/article/details/52210975)

· 字符串匹配暴力法代码示例

```java
public static int forceSearch(String txt,String pat) {
    int M = txt.length();
    int N = pat.length();
    
    for(int i = 0; i<= M-N;i++) {
        int j;
        for(j = 0; j<N;j++) {
            if(txt.charAt(i+j) != pat.charAt(j))
                break;
        }
        if(j == N) {
            return i;
        }
    }
    return -1;
}
```

> 在朴素算法中，我们需要挨个比较所有字符，才知道目标字符串中是否包含子串。那么，是否有别的方法可以用来判断目标字符串是否包含子串呢?
>
> 答案是肯定的，确实存在一种更快的方法。为了避免挨个字符对目标字符串和子串进行比较，我们可以尝试一次性判断两者是否相等。因此，我们需要一个好的哈希函数(hash function)。通过哈希函数，我们可以算出子串的哈希值,然后将它和目标字符串中的子串的哈希值进行比较。这个新方法在速度上比暴力法有显著提升。
>
> ===============================================================================
>
> Rabin-Karp算法的思想:
>
> 1.假设子串的长度为M (pat)， 目标字符串的长度为N (txt) 
>
> 2.计算子串的hash值hash_pat
>
> 3.计算目标字符串txt中每个长度为M的子串的hash值(共需要计算N-M+1次)
>
> 4.比较hash值:如果hash值不同，字符串必然不匹配;如果hash值相同，还需要使用朴素算法再次判断

· Rabin-Karp 代码示例

 ```java
 public final static int D = 256;
 public final static int Q = 9997;
 
 static int RabinKarpSearch(String txt,String pat) {
     int M = pat.length();
     int N = txt.length();
     int i,j;
     int patHash = 0,txtHash = 0;
     
     for(i = 0;i<M;i++) {
         patHash = (D*patHash + pat.charAt(i)) %Q;
         txtHash = (D*txtHash + txt.charAt(i)) %Q;
     }
     
     int highestPow = 1; //pow(256,M-1)
     for(int i = 0;i<M-1;i++) 
         highestPow = (hightestPow * D) % Q;
     
     for(i = 0; i<= N-M;i++) {//枚举起点
         if(patHash == txtHash) {
             for(j = 0; j<M;j++) {
                 if(txt.charAt(i+j) != pat.charAt(j))
                     break;
             }
             
             if(j == M) {
                 return i;
             }
         }
         //最高一位走出去，最低一位进来
         if(i < N-M) {
             txtHash = (D * (txtHash - txt.charAt(i) * highestPow) + txt.charAt(i + M) %Q);
             if(txtHash < 0)
                 txtHash += Q;
         }
         
     }
     return -1;
 }
 ```



· [KMP 字符串匹配算法视频](https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171)

· [字符串匹配的 KMP 算法  ](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)

### 课后作业

· https://leetcode-cn.com/problems/first-unique-character-in-a-string/

· https://leetcode-cn.com/problems/string-to-integer-atoi/

· https://leetcode-cn.com/problems/reverse-string-ii/

· https://leetcode-cn.com/problems/reverse-words-in-a-string/

· https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/

· https://leetcode-cn.com/problems/reverse-only-letters/

· https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/

· https://leetcode-cn.com/problems/longest-palindromic-substring/

· https://leetcode-cn.com/problems/isomorphic-strings/

· https://leetcode-cn.com/problems/valid-palindrome-ii/

· https://leetcode-cn.com/problems/wildcard-matching

· https://leetcode-cn.com/problems/longest-valid-parentheses

· https://leetcode-cn.com/problems/distinct-subsequences/

