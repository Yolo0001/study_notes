# 二叉树的递归遍历

[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preOrder(root,res);
        return res;
    }

    public void preOrder(TreeNode root,List<Integer> res) {
        if(root == null) return;

        res.add(root.val);
        preOrder(root.left,res);
        preOrder(root.right,res);
    }
}

//后序
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        postOrder(root,res);
        return res;
    }

    public void postOrder(TreeNode root,List<Integer> res) {
        if(root == null) return;

        
        postOrder(root.left,res);
        postOrder(root.right,res);
        res.add(root.val);
    }
}
//中序
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inOrder(root,res);
        return res;
    }

    public void inOrder(TreeNode root,List<Integer> res) {
        if(root == null) return;

        
        inOrder(root.left,res);
        res.add(root.val);
        inOrder(root.right,res);
        
    }
}
```



# 二叉树的迭代遍历

```java
// 前序遍历顺序：中-左-右，入栈顺序：中-右-左
class solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) {
            return res;
        }
        
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            res.add(node.val);
            if(node.right != null) {
                stack.push(node.right);
            }
            if(node.left != null) {
                stack.push(node.left);
            }
        }
        return res;
    }
}

// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果
class solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) {
            return result;
        }
        
        Stack<TreeNode stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.add(node.val);
            if(node.left != null){
                stack.push(node.left);
            }
            if(node.right != null) {
                stack.push(node.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
}

// 中序遍历顺序: 左-中-右 入栈顺序： 左-右
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while(cur != null || !stack.isEmpty()) {
            if(cur != null) { // 指针来访问节点，访问到最底层
                stack.push(cur); // 将访问的节点放进栈
                cur = cur.left; // 左
            }else {
                cur = stack.pop(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                res.add(cur.val);  // 中
                cur = cur.right;   // 右
            }
        }
        return res;
    }
}
```

# 二叉树的统一迭代法

```java
//先序 ，中 左 右
class Solution {
    public List<Integer> preorderTraver(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if(root != null) st.push(root);
        while(!st.empty()) {
            TreeNode node = st.peek();
            if(node != null) {
                st.pop();// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if(node.right!=null) st.push(node.right); 	// 添加右节点（空节点不入栈）
                if(node.left!=null) st.push(node.left); 	// 添加左节点（空节点不入栈）
                st.push(node);							 // 添加中节点
                st.push(null);		// 中节点访问过，但是还没有处理，加入空节点做为标记。
             
            }else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();	// 将空节点弹出
                node = st.pop(); // 重新取出栈中元素

                res.add(node.val);  // 加入到结果集
            }
        }
        return res;
    }
}

//中序遍历 左 中 右
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if(root != null) st.push(root);
        while(!st.empty()) {
            TreeNode node = st.peek();
            if(node != null) {
                st.pop(); 			// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if(node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈）
                st.push(node); 		// 添加中节点
                st.push(null); 		// 中节点访问过，但是还没有处理，加入空节点做为标记。
                if(node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈）
            }else { 				// 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();			// 将空节点弹出
                node = st.peek();	// 重新取出栈中元素
                st.pop();
                res.add(node.val); 	// 加入到结果集
            }
        }
    }
}
//后序遍历 左 右 中
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if(root != null) st.push(root);
        while(!st.empty()) {
            TreeNode node = st.peak();
            if(node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                st.push(node);	 // 添加中节点
                st.push(null);	// 中节点访问过，但是还没有处理，加入空节点做为标记。
                if(node.right!=null) st.push(node.right);	// 添加右节点（空节点不入栈）
                if(node.left!=null) st.push(node.left);	 // 添加左节点（空节点不入栈）  
            }else {				// 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();		// 将空节点弹出
                node = st.peak();	// 重新取出栈中元素
                st.pop();
                res.add(node.val);	// 加入到结果集
            }
        }
        return res;
    }
}
```

# 二叉树的层序遍历

## 102.二叉树的层序遍历

[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        //checkFun01(root,0);
        checkFun02(root);
        
        return resList;
    }
    
    //DFS--递归方式
    public void checkFun01(TreeNode node,Integer deep) {
        if (node == null) return;
        deep++;
        
        if(resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);
        
        checkFun01(node.left,deep);
        checkFun01(node.right,deep);
    }
    
     //BFS--迭代方式--借助队列
    public void checkFun02(TreeNode node) {
        if(node == null) return;
        Queue<TreeNode> que = new LinkedList<TreeNode>();
        que.offer(node);
        
        while(!que.isEmpty()) {
            List<Integer> itemList = new ArrayList<Integer>();
            int len = que.size();
            
            while (len > 0) {
                TreeNode tmpNode = que.poll();
                itemList.add(tmpNode.val);
                
                if(tmpNode.left != null) que.offer(tmpNode.left);
                if(tmpNOde.right != null) que.offer(tmpNode.right);
                len--;
            }
            
            resList.add(itemList);
        }
    }
}
```

# 226.翻转二叉树

[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/)

```java
//DFS递归
class Solution {
     /**
     * 前后序遍历都可以
     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）
     */
    public TreeNode invertTree(TreeNode root) {
        if(root == null) {
            return null;
        }
        invertTree(root.left); 
        ivertTree(root.right);
        swapChildren(root);
        return root;
    }
    
    private void swapChildren(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
}

//BFS
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        ArrayDeque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            while(size-- > 0) {
                TreeNode node = deque.poll();
                swap(node);
                if(node.left != null) {deque.offer(node.left);}
                if(node.right != null) {deque.offer(node.right);}
            }
        }
        return root;
    }
    
    public void swap(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
```

# 101. 对称二叉树

[力扣题目链接](https://leetcode-cn.com/problems/symmetric-tree/)

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**

这两道题目基本和本题是一样的，只要稍加修改就可以AC。

- 100.相同的树
- 572.另一个树的子树

```java
/**
* 递归法
*/
public boolean isSymmetric1(TreeNode root) {
    return compare(root.left,root.right);
}

private boolean compare(TreeNode left,TreeNode right) {
    if (left == null && right != null) {
        return false;
    }else if(left != null && right == null) {
        return false;
    }else if (left == null && right ==null) {
        return true;
    }else if(left.val != right.val) {
        return false;
    }
    // 比较外侧
    boolean compareOutside = compare(left.left,right.right);
     // 比较内侧
    boolean compareInside = compare(left.right,right.left);
    
    return compareOutside && compareInside;
}

    /**
     * 迭代法
     * 使用双端队列，相当于两个栈
     */
public boolean isSymmetric2(TreeNode root) {
    Deque<TreeNode> deque = new LinkedList<>();
    deque.offerFirst(root.left);
    deque.offerLast(root.right);
    while(!deque.isEmpty()) {
        TreeNode leftNode = deque.pollFirst();
        TreeNode rightNode = deque.pollLast();
        if (leftNode == null && rightNode == null) {
            continue;
        }
        
        if (leftNode == null || rightNode == null || leftNode.val != rightNOde.val) {
            return false;
        }
        
        deque.offerFirst(leftNode.left);
        deque.offerFirst(leftNode.right);
        deque.offerLast(rightNode.right);
        deque.offerLast(rightNode.left);
    }
    return true;
}
	/**
     * 迭代法
     * 使用普通队列
     */
public boolean isSymmetric3(TreeNode root) {
    Queue<TreeNode> deque = new LinkedList<>();
    deque.offer(root.left);
    deque.offer(root.right);
    
    while(!deque.isEmpty()) {
        TreeNode leftNode = deque.poll();
        TreeNode rightNode = deque.poll();
        
        if (leftNode == null && rightNode == null) {
            continue;
        }
        
        if(leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
            return false;
        }
        
        deque.offer(leftNode.left);
        deque.offer(rightNOde.right);
        deque.offer(leftNode.right);
        deuqe.offer(rightNode.left);
    }
    return true;
}
```

# 104.二叉树的最大深度

[力扣题目链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。



看完本篇可以一起做了如下两道题目：

- 104.二叉树的最大深度
- 559.n叉树的最大深度

```java
class solution {
    /**
     * 递归法
     */
    public int maxdepth(treenode root) {
        if(root == null) {
            return 0;
        }
        int leftdepth = maxdepth(root.left);
        int rightdepth = maxdepth(root.right);
        return math.max(leftdepth,rightdepth) + 1;
    }
}
```

```java
class solution {
    /**
     * 迭代法，使用层序遍历
     */
    public int maxdepth(treenode root) {
        if(root == null) {
            return 0;
        }
        deque<treenode> deque = new linkedlist<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size;i++) {
                treenode poll = deque.poll();
                if (poll.left != null) {
                    deque.offer(poll.left);
                }
                if (poll.right != null) {
                    deque.offer(poll.right);
                }
            }
        }
        return depth;
    }
}
```

# 559.n叉树的最大深度

```java
class Solution {
     /*递归法，后序遍历求root节点的高度*/
    public int maxDepth(Node root) {
        if (root == null) return 0;
        
        int depth = 0;
        if (root.children != null) {
            for (Node child : root.children) {
                depth = Math.max(depth,maxDepth(child));
                
            }
        }
        return depth + 1;//中节点
    }
}
```

```java
class Solution {
    /**
     * 迭代法，使用层序遍历
     */
    public int maxDepth(Node root) {
        if (root == null) return 0;
        int depth = 0;
        Queue<Node> que = new LinkedList<>();
        que.offer(root);
        while(!que.isEmpty()) {
            depth ++;
            int len = que.size();
            while (len > 0) {
                Node node = que.poll();
                for (int i = 0;i < node.children.size();i++) {
                    if(node.children.get(i) != null)
                        que.offer(node.children.get(i));
                }
                len--;
            }
        }
        return
    }
}
```

# 111.二叉树的最小深度

[力扣题目链接](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```java
class Solution {
    /**
     * 递归法，相比求MaxDepth要复杂点
     * 因为最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量
     */
    public int minDepth(TreeNode root ) {
        if(root == null) {
            return 0;
        }
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);
        if(root.left == null) {
            return rightDepth + 1;
        }
        if(root.right == null) {
            return leftDepth + 1;
        }
        // 左右结点都不为null
        return Math.min(leftDepth,rightDepth) + 1;
    }
}
```

```java
class Solution {
    /**
     * 迭代法，层序遍历
     */
	public int minDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while(!deque.isEmpty()) {
            int depth = 0;
            depth++;
            for (int i = 0;i < size;i++) {
                TreeNode poll = deque.poll();
                if (poll.left == null && poll.right == null) {
                    // 是叶子结点，直接返回depth，因为从上往下遍历，所以该值就是最小值
                    return depth;
                }
                if (poll.left != null) {
                    deque.offer(poll.left);
                }
                if (poll.right != null) {
                    deque.offer(poll.right);
                }
            }
        }
        return depth;
    }
}
```

# 222.完全二叉树的节点个数

[力扣题目链接](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```java
class Solution {
    // 通用递归解法
    public int countNodes(TreeNode root) {
        if(root == null) return 0;
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

```java
class Solution {
     // 迭代法
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int result = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size-- > 0) {
                TreeNode cur = queue.poll();
                result++;
                if (cur.left != null) queue.offer(cur.left);
                if (cur.right != null) queue.offer(cur.right);
            }
        }
        return result;
    }
}
```

```java
class Solution {
    /**
     * 针对完全二叉树的解法
     *
     * 满二叉树的结点数为：2^depth - 1
     */
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        int leftDepth = getDepth(root.left);
        int rightDepth = getDepth(root.right);
        
        if (leftDepth == rightDepth) {// 左子树是满二叉树
            // 2^leftDepth其实是 （2^leftDepth - 1） + 1 ，左子树 + 根结点
            return (1<<leftDepth) + countNodes(root.right);
        }else {// 右子树是满二叉树
            return (1<<rightDepth) + countNodes(root.left);
        }
    }
    
    private int getDepth(TreeNode root) {
        int depth = 0;
        while (root != null) {
            root = root.left;
            depth++;
        }
        return depth;
    }
}
```

# 110.平衡二叉树

[力扣题目链接](https://leetcode-cn.com/problems/balanced-binary-tree/)

```java
class Solution {
     /**
     * 递归法
     */
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }
    
    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        if(leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        
        // 左右子树高度差大于1，return -1表示已经不是平衡树了
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        return Math.max(leftHeight,rightHeight) + 1;
    }
}


class Solution {
    /**
     * 迭代法，效率较低，计算高度时会重复遍历
     * 时间复杂度：O(n^2)
     */
    public boolean isBalanced(TreeNode root) {
        if(root == null) {
            return true;
        }
        
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while(root != null || !stack.isEmpty()) {
            while(root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 比较左右子树的高度差，输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            }else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }
    
    /**
     * 层序遍历，求结点的高度
     */
    public int getHeight(TreeNode root) {
        if(root == null) return 0;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root) ;
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size;i++) {
                TreeNode poll = deque.poll();
                if (poll.left != null) {
                    deque.offer(poll.left);
                }
                if (poll.right != null) {
                    deque.offer(poll.right);
                }
            }
        }
        return depth;
    }
}


class Solution {
     /**
     * 优化迭代法，针对暴力迭代法的getHeight方法做优化，利用TreeNode.val来保存当前结点的高度，这样就不会有重复遍历
     * 获取高度算法时间复杂度可以降到O(1)，总的时间复杂度降为O(n)。
     * 时间复杂度：O(n)
     */
    public boolean isBalanced(TreeNode root) {
        if(root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
             // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            }else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
            
        }
        return true;
    }
    
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = root.left != null ? root.left.val : 0;
        int rightHeight = root.right != null ? root.right.val : 0;
        int height = Math.max(leftHeight,rightHeight) + 1;
        root.val = height;//用TreeNode.val来保存当前结点的高度
        return 
    }
}
```

# 257. 二叉树的所有路径

[力扣题目链接](https://leetcode-cn.com/problems/binary-tree-paths/)

### 思路

这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。

在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。

前序遍历以及回溯的过程如图：

![](D:\Study\自学\笔记\img\20210204151702443.png)

```java
class Solution {
    /**
     * 递归法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        
        if(root == null) {
            return res;
        }
        List<Integer> paths = new ArrayList<>();
        
        traversal(root,paths,res);
        return res;
    }
    
    private void traversal(TreeNode root,List<Integer> paths,List<String> res) {
        paths.add(root.val);
        // 叶子结点
        if(root.left == null && root.right == null) {
            StringBuilder sb = new StringBuilder();
            // 输出
            for(int i = 0; i < paths.size() - 1;i++) {
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1));
            res.add(sb.toString());
            return ;
        }
        if(root.left != null) {
            traversal(root.left,paths,res);
            paths.remove(paths.size() - 1);// 回溯
        }
        if(root.right != null) {
            traversal(root.right,paths,res);
            paths.remove(paths.size() - 1);// 回溯
        }
    }
}
//如下为精简之后的递归代码
class Solution {
  public void traversal(TreeNode cur, String path, List<String> result) {
      path += cur.val; // 中
      if (cur.left == null && cur.right == null) {
          result.add(path);
          return;
      }
      if (cur.left!=null) traversal(cur.left, path + "->", result); // 左  回溯就隐藏在这里
      if (cur.right!=null) traversal(cur.right, path + "->", result); // 右 回溯就隐藏在这里
  }

  public List<String> binaryTreePaths(TreeNode root) {
      List<String> result = new LinkedList<>();
      String path = "";
      if (root == null) return result;
      traversal(root, path, result);
      return result;
  }
}


// 解法2
class Solution {
    /**
     * 迭代法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if(root == null) {
            return result;
        }
        Stack<Object> stack = new Stack<>();
         // 节点和路径同时入栈
        stack.push(root);
        stack.push(root.val + "");
        while(!stack.isEmpty()) {
            // 节点和路径同时出栈
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // 若找到叶子节点
            if(node.left == null && node.right == null) {
                result.add(path);
            }
            //右子节点不为空
            if(node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" +node.right.val);
            }
            //左子节点不为空
            if(node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
        
    }
}
```

# 100.相同的树:递归代码

[100. 相同的树 - 力扣（LeetCode）](https://leetcode.cn/problems/same-tree/)

```java
class Solution {
    
    boolean isSameTree(TreeNode p,TreeNode q) {
        return compare(p,q);
    }
    
    public boolean compare(TreeNode tree1, TreeNode tree2) {
        if(tree1==null && tree2==null) return true;
        if(tree1==null || tree2==null) return false;
        if(tree1.val != tree2.val) return false;
        // 此时就是：左右节点都不为空，且数值相同的情况
      	// 此时才做递归，做下一层的判断
        boolean compareLeft = compare(tree1.left,tree2.left);  // 左子树：左、 右子树：左
        boolean compareRight = compare(tree1.right,tree2.right); // 左子树：右、 右子树：右
        boolean isSame = compareLeft && compareRight; // 左子树：中、 右子树：中（逻辑处理）
        return isSame;
    }
}
```

# 404.左叶子之和

[力扣题目链接](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```java
//递归
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        
        int leftValue = sumOfLeftLeaves(root.left);// 左
        int rightValue = sumOfLeftLeaves(root.right);// 右
        int midValue = 0;
        if(root.left != null && root.left.left == null && root.right.right == null) {
            midValue = root.left.val;
        }
        
        int sum = midValue + leftValue + rightValue; //中
        return sum;
    }
}

//迭代
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        
        Stack<TreeNode> stack = new Stack<>();
        
        stack.add(root);
        int result = 0;
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(node.left != null && node.left.left == null && node.left.right == null) {
                result = node.left.val;
            }
            
            if (node.right != null) stack.add(node.right);
            if (node.left != null) stack.add(node.left);
        }
        return result;
    }
}

// 层序遍历迭代法

class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        int sum = 0;
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            while(size-- > 0) {
                TreeNode node = queue.poll();
                if(node.left != null) {// 左节点不为空
                    queue.offer(node.left);
                    if(node.left.left == null && node.left.right == null) {
                        sum += node.left.val;
                    }
                }
                if(node.right != null) queue.offer(node.right);
            }
        }
        return sum;
    }
}
```

# 513.找树左下角的值

[力扣题目链接](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```java
// 递归法
class Solution {
    private int Deep = -1;
    private int value = 0;
    
    public int findBottomLeftValue(TreeNode root) {
        value = root.val;
        findLeftValue(root,0);
        return value;
    }
    
    private void findLeftValue(TreeNode root,int deep) {
        if(root == null) return ;
        
        if(root.left == null && root.right == null) {
            if(deep > Deep) {
                value = root.value;
                Deep = deep;
            }
        }
        
        if(root.left != null) findLeftValue(root.left,deep+1);
        if(root.right != null) findLeftValue(root.right,deep+1);
    }
    
}

//迭代法
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        
        queue.offer(root);
        int res = 0;
        
        while(!root.isEmpty()) {
            int size = queue.size();
            for (int i = 0;i<size;i++) {
                TreeNode poll = queue.poll();
                if(i == 0) {
                    res = poll.val;
                }
                if (poll.left != null) {
                    queue.offer(poll.left);
                }
                if(poll.right != null) {
                    queue.offer(poll.right);
                }
            }
        }
        return
    }
}
```

# 112. 路径总和

[力扣题目链接](https://leetcode-cn.com/problems/path-sum/)

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

```java
class Solution {
    public boolean haspathsum(treenode root,int targetsum) {
        if (root == null) {
            return false;
        }
        targetsum -= root.val;
        // 叶子结点
        if(root.left == null && root.right == null) {
            return targetsum == 0;
        }
        
        if(root.left != null) {
            boolean left = haspathsum(root.left,targetsum);
            if(left) {// 已经找到
                return true;
            }
        }
        if(root.right != null) {
            boolean right = haspathsum(root.right,targetsum);
            if(right) {
                return true;
            }
        }
        return false;
    }
}

// lc112 简洁方法
class solution {
    public boolean haspathsum(treenode root,int targetsum) {
       if(root == null) return false;
        
        if(root.left == null && root.right == null) {
            return root.val == targetsum;
        }
        // 求两侧分支的路径和
        return haspathsum(root.left,targetsum - root.val) || haspathsum(root.right,targetsum - root.val);
        
    }
}
```

```java
//迭代
class Solution {
    public boolean haspathsum(treenode root, int targetsum) {
        if(root == null) return false;
        
        Stack<treenode> stack1 = new Stack<>();
        Stack<integer> stack2 = new Stack<>();
        stack1.push(root);
        stack2.push(root.val);
        while(!stack1.isEmpty()) {
            int size = stack1.size();
            for (int i=0;i<size;i++) {
                treenode node = stack1.pop();
                int sum = stack2.pop();
                // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
                if(node.left == null && node.right == null && sum == targetsum) return true;
                 // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
                if(node.right!=null) {
                    stack1.push(node.right);
                    stack2.push(sum+node.right.val);
                }
                 // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
                if(node.left!=null) {
                    stack1.push(node.left);
                    stack2.push(sum+node.left.val);
                }
            }
        }
        return false;
        
    }
}
```

# 113. 路径总和ii

[力扣题目链接](https://leetcode-cn.com/problems/path-sum-ii/)

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

```java
class Solution {
    public List<List<Integer>> pathsum(TreeNode root,int targetsum) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        
        List<Integer> path = new LinkedList<>();
        preorderdfs(root,targetsum,res,path);
        return res;
    }
    
    public void preorderdfs(TreeNode root,int targetsum,List<List<Integer>> res,List<Integer> path) {
        path.add(root.val);
        // 遇到了叶子节点
        if(root.left == null && root.right == null) {
            // 找到了和为 targetsum 的路径
            if(targetsum - root.val==0) {
                res.add(new ArrayList<>(path));
            }
            return ;// 如果和不为 targetsum，返回
        }
        
        if(root.left != null) {
            preorderdfs(root.left,targetsum - root.val,res,path);
            path.remove(path.size() - 1); // 回溯
        }
        
        if(root.right != null) {
            preorderdfs(root.right,targetsum - root.val,res,path);
            path.remove(path.size() - 1);
        }
    }
    
}

// 解法2
class Solution {
    List<List<Integer>> result;
    LinkedList<Integer> path;
    public List<List<Integer>> pathSum(TreeNode root,int targetSum) {
        result = new LinkedList<>();
        path = new LinkedList<>();
        travesal(root,targetSum);
        return result;
    }
    
    private void travesal(TreeNode root,int count) {
        if(root == null) return ;
        path.offer(root.val);
        count -= root.val;
        if(root.left == null && root.right == null && count == 0) {
            result.add(new LinkedList<>(path));
        }
        travesal(root.left,count);
        travesal(root.right,count);
        path.removeLast();// 回溯
    }
}
```

# 106.从中序与后序遍历序列构造二叉树

[力扣题目链接](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

根据一棵树的中序遍历与后序遍历构造二叉树。

注意: 你可以假设树中没有重复的元素。

![](D:\Study\自学\笔记\img\20210203154249860.png)

- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
- 第五步：切割后序数组，切成后序左数组和后序右数组
- 第六步：递归处理左区间和右区间

```java
class Solution {
    public TreeNode buildTree(int[] inorder,int[] postorder) {
        return buildTree1(inorder,0,inorder.length,postorder,0,postorder.length);
    }
    
    public TreeNode buildTree1(int[] inorder,int inLeft,int inRight,
                              int[] postorder,int postLeft,int postRight) {
        // 没有元素了
        if(inRight - inLeft < 1) return null;
        // 只有一个元素了
        if(inRight - inLeft == 1) {
            //左闭右开
            return new TreeNode(inorder[inLeft]);
        }
        // 后序数组postorder里最后一个即为根结点
        int rootVal = postorder[postRight - 1];
        TreeNode root = new TreeNode(rootVal);
        int rootIndex = 0;
        // 根据根结点的值找到该值在中序数组inorder里的位置
        for (int i = inLeft;i < inRight; i++) {
            if(inorder[i] == rootVal) {
                rootIndex = i;
                break;
            }
        }
        // 根据rootIndex划分左右子树
        root.left = buildTree1(inorder,inLeft,rootIndex,postorder,postLeft,postLeft + (rootIndex - inLeft));
        root.right = buildTree1(inorder,rootIndex + 1,inRight,postorder,postLeft + (rootIndex - inLeft),postRight - 1);
        return root;
        
    }
}
```

105.从前序与中序遍历序列构造二叉树

```java
class Solution {
    //先 中左右 中 左中右
    public TreeNode buildTree(int[] preorder,int[] inorder) {
        return buildTree1(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }
    
    public TreeNode buildTree1(int[] preorder,int preLeft,int preRight,
                              int[] inorder,int inLeft,int inRight) {
        // 递归终止条件
        if(inLeft > inRight || preLeft > preRight) return null;
        // val 为前序遍历第一个的值，也即是根节点的值
        // idx 为根据根节点的值来找中序遍历的下标
        int idx = inLeft,val = preorder[preLeft];
        TreeNode root = new TreeNode(val);
        for (int i = inLeft;i <= inRight;i++) {
            if(inorder[i] == val) {
                idx = i;
                break;
            }
        }
        
        // 根据 idx 来递归找左右子树
        root.left = buildTree1(preorder,preLeft + 1,preLeft+(idx - inLeft),
                              inorder,inLeft,idx - 1);
        root.right = buildTree1(preorder,preLeft+(idx - inLeft) + 1,preRight
                               inorder,idx+1,inRight);
        return root;
    }
}
```

# 654.最大二叉树

[力扣题目地址](https://leetcode-cn.com/problems/maximum-binary-tree/)

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。



构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return helper(nums,0,nums.length);
    }

    public TreeNode helper(int[] nums,int leftIndex,int rightIndex) {
        if(rightIndex - leftIndex < 1) return null;

        if(rightIndex - leftIndex == 1) return new TreeNode(nums[leftIndex]);

        int maxIndex = leftIndex;
        int maxVal = nums[maxIndex];
        for (int i = leftIndex+1; i < rightIndex; i++) {
            if (nums[i] > maxVal) {
                maxVal = nums[i];
                maxIndex = i;
            }
        }

        TreeNode root = new TreeNode(maxVal);
        root.left = helper(nums,leftIndex,maxIndex);
        root.right = helper(nums,maxIndex+1,rightIndex);
        return root;
    }
}

```

# 617.合并二叉树

[力扣题目链接](https://leetcode-cn.com/problems/merge-two-binary-trees/)

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        // 递归
        if (root2 == null) return root1;
        if (root1 == null) return root2;

        TreeNode newRoot = new TreeNode(root1.val + root2.val);
        newRoot.left = mergeTrees(root1.left,root2.left);
        newRoot.right = mergeTrees(root1.right,root2.right);
        return newRoot;
    }
}
```

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        // 使用栈迭代
        if (root2 == null) return root1;
        if (root1 == null) return root2;

        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root2);
        stack.push(root1);

        while(!stack.isEmpty()) {
            TreeNode node1 = stack.pop();
            TreeNode node2 = stack.pop();

            node1.val += node2.val;
            if (node2.right != null && node1.right != null) {
                stack.push(node2.right);
                stack.push(node1.right);
            }else {
                if (node1.right == null) {
                    node1.right = node2.right;
                }
            }
            if(node1.left != null && node2.left != null) {
                stack.push(node2.left);
                stack.push(node1.left);
            }else {
                if(node1.left == null) {
                    node1.left = node2.left;
                }
            }
        }
        return root1;

    }
}
```

# 700.二叉搜索树中的搜索

[力扣题目地址](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

```java
class Solution {
    // 递归，普通二叉树
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) return root;

        TreeNode left = searchBST(root.left,val);
        if (left != null) {
            return left;
        }
        return searchBST(root.right,val);
    }
}


class Solution {
    // 递归，利用二叉搜索树特点，优化
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) return root;

        if (val < root.val) {
            return searchBST(root.left,val);
        }else {
            return searchBST(root.right,val);
        }
    }
}

class Solution {
    // 迭代，普通二叉树
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) return root;

        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);
        
        while(!stack.isEmpty()) {
            TreeNode pop = stack.pop();
            if (pop.val == val) {
                return pop;
            }
            if (pop.right != null) {
                stack.push(pop.right);
            }
            if (pop.left != null) {
                stack.push(pop.left);
            }
        }
        return null;
    }
}

class Solution {
    // 迭代，利用二叉搜索树特点，优化，可以不需要栈
    public TreeNode searchBST(TreeNode root, int val) {
        while(root != null) {
            if (val < root.val) root = root.left;
            else if (val > root.val) root = root.right;
            else return root;
        }
        return null;

    }
}
```

# 98.验证二叉搜索树

[力扣题目链接](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

```java
class Solution {
    // 递归
    TreeNode max;
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;

        // 左
        boolean left = isValidBST(root.left);
        if(!left) {
            return false;
        }
		// 中
        if(max != null && root.val <= max.val) {
            return false;
        }
        max = root;
        
        // 右
        boolean right = isValidBST(root.right);
        return right;

    }
}

class Solution {
	// 迭代
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode pre =null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;// 左
            }
			// 中，处理
            TreeNode pop = stack.pop();
            if (pre != null && pop.val <= pre.val) {
                return false;
            }

            pre = pop;

            root = pop.right;// 右
        }
        return true;
    }
}

// 简洁实现·递归解法
class Solution {
    public boolean isValidBST(TreeNode root) {
        return validBST(Long.MIN_VALUE,Long.MAX_VALUE,root);
    }

    boolean validBST(long lower, long upper, TreeNode root) {
        if (root == null) return true;

        if (root.val <= lower || root.val >= upper) return false;
        return validBST(lower, root.val, root.left) && validBST(root.val,upper,root.right);
    }
}
// 简洁实现·中序遍历
class Solution {

    private long prev = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;

        if (!isValidBST(root.left)) {
            return false;
        }

        if (root.val <= prev) {
            return false;
        }

        prev = root.val;
        return isValidBST(root.right);


    }
}
```

# 530.二叉搜索树的最小绝对差

[力扣题目链接](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

```java
class Solution {
    //递归
    TreeNode pre;// 记录上一个遍历的结点
    int result =Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        if (root == null) return 0;
        traversal(root);
        return result;
    }

    private void traversal(TreeNode root) {
        if (root == null) return;
		//左
        traversal(root.left);
		//中
        if (pre != null) {
            result = Math.min(result,root.val-pre.val);
        }

        pre = root;
		//右
        traversal(root.right);
    }
}

class Solution {
    //迭代法-中序遍历
    TreeNode pre;
    Stack<TreeNode> stack;
    public int getMinimumDifference(TreeNode root) {
        if (root == null) return 0;
        stack = new Stack<TreeNode>();

        TreeNode cur =root;
        int result = Integer.MAX_VALUE;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);// 将访问的节点放进栈
                cur = cur.left;// 左
            }else {
                cur = stack.pop();
                if (pre != null) {// 中
                    result = Math.min(result,cur.val - pre.val);
                }
                pre = cur;
                cur = cur.right;
            }
        }
        return result;
    }
}
```

# 501.二叉搜索树中的众数

[力扣题目链接](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/)

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

```java
class Solution {
    public int[] findMode(TreeNode root) {
        Map<Integer,Integer> map = new HashMap<>();
        List<Integer> list = new ArrayList<>();
        if (root == null) return list.stream().mapToInt(Integer::intValue).toArray();
        
        // 获得频率 Map
        searchBST(root,map);
		
        List<Map.Entry<Integer,Integer>> mapList = map.entrySet().stream()
                .sorted((c1,c2) -> c2.getValue().compareTo(c1.getValue()))
                .collect(Collectors.toList());

        list.add(mapList.get(0).getKey());
		// 把频率最高的加入 list
        for (int i = 1; i < mapList.size(); i++) {
            if (mapList.get(i).getValue() == mapList.get(i-1).getValue()) {
                list.add(mapList.get(i).getKey());
            }else {
                break;
            }
        }
        return list.stream().mapToInt(Integer::intValue).toArray();
    }

    private void searchBST(TreeNode curr, Map<Integer, Integer> map) {
        if (curr == null) return ;
        map.put(curr.val,map.getOrDefault(curr.val,0)+1);
        searchBST(curr.left,map);
        searchBST(curr.right,map);
    }
}

//中序遍历-不使用额外空间，利用二叉搜索树特性
class Solution {
    ArrayList<Integer> resList;
    int maxCount;
    int count;
    TreeNode pre;
    public int[] findMode(TreeNode root) {
        resList = new ArrayList<>();
        maxCount = 0;
        count = 0;
        pre = null;

        findMode1(root);

        int[] res = new int[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);

        }
        return res;
    }

    private void findMode1(TreeNode root) {
        if (root == null) return ;
        findMode1(root.left);

        int rootValue = root.val;

        if (pre == null || rootValue != pre.val) {
            count = 1;
        }else {
            count++;
        }

        if (count > maxCount) {
            resList.clear();
            resList.add(rootValue);
            maxCount = count;
        }else if (count == maxCount) {
            resList.add(rootValue);
        }
        pre = root;
        findMode1(root.right);
    }
}

//迭代法
class Solution {

    public int[] findMode(TreeNode root) {
        TreeNode pre = null;
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> result = new ArrayList<>();
        int maxCount = 0;
        int count = 0;
        TreeNode cur = root;
        while(cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }else {
                cur = stack.pop();
				// 计数
                if (pre == null || cur.val != pre.val) {
                    count = 1;
                }else {
                    count++;
                }
				// 更新结果
                if (count > maxCount) {
                    maxCount = count;
                    result.clear();
                    result.add(cur.val);
                }else if (count == maxCount) {
                    result.add(cur.val);
                }
                pre =cur;
                cur = cur.right;
            }
        }

        return result.stream().mapToInt(Integer::intValue).toArray();

    }
}
```

# 236. 二叉树的最近公共祖先

[力扣题目链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) {
            return root;
        }

        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);

        if (left == null && right == null) {
            return null;
        }else if (left == null && right!= null) {
            return right;
        }else if (left != null && right == null) {
            return left;
        }else {
            return root;
        }
    }
}
```

# 235. 二叉搜索树的最近公共祖先

[力扣题目链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > p.val) {
            return lowestCommonAncestor(root.left,p,q);
        }
        if (root.val < p.val && root.val < q.val) {
            return lowestCommonAncestor(root.right,p,q);
        }
        return root;
    }
}

//迭代法
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        while (true) {
            if (root.val > p.val && root.val > q.val) {
                root = root.left;
            }else if (root.val < p.val && root.val < q.val) {
                root = root.right;
            }else {
                break;
            }
        }
        return root;
    }
}
```

# 701.二叉搜索树中的插入操作

[力扣题目链接](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }

        if (root.val < val) {
            root.right = insertIntoBST(root.right,val);
        }else if (root.val > val) {
            root.left = insertIntoBST(root.left,val);
        }
        return root;
    }
}

class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null ) return new TreeNode(val);
        TreeNode newRoot = root;
        TreeNode pre = root;
        while(root != null) {
            pre = root;
            if (root.val < val) {
                root = root.right;
            }else if (root.val > val) {
                root = root.left;
            }
        }
        if (pre.val < val) {
            pre.right = new TreeNode(val);
        }else if (pre.val > val) {
            pre.left = new TreeNode(val);
        }
        return newRoot;
    }
}
```

# 450.删除二叉搜索树中的节点

[力扣题目链接](https://leetcode.cn/problems/delete-node-in-a-bst/)

- 第一种情况：没找到删除的节点，遍历到空节点直接返回了
- 找到删除的节点
  - 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
  - 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
  - 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
  - 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        root = delete(root,key);
        return root;
    }

    private TreeNode delete(TreeNode root, int key) {
        if (root == null) return null;

        if (root.val > key) {
            root.left = delete(root.left,key);
        }else if (root.val < key) {
            root.right = delete(root.right,key);
        }else {
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            TreeNode tmp = root.right;
            while (tmp.left != null) {
                tmp = tmp.left;
            }
            root.val = tmp.val;
            root.right = delete(root.right,tmp.val);

        }
        return root;
    }
}


```

# 669. 修剪二叉搜索树

[力扣题目链接](https://leetcode.cn/problems/trim-a-binary-search-tree/)

给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) return null;

        if (root.val < low) {
            return trimBST(root.right,low,high);
        }
        if (root.val > high) {
            return trimBST(root.left,low,high);
        }
        root.left = trimBST(root.left,low,high);
        root.right = trimBST(root.right,low,high);
        return root;
    }
}
```

# 108.将有序数组转换为二叉搜索树

[力扣题目链接](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

```java
//递归: 左闭右开 [left,right)
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return sortedArrayToBST(nums,0,nums.length);
    }

    private TreeNode sortedArrayToBST(int[] nums, int left, int right) {
        if (left >= right) {
            return null;
        }
        if (right - left == 1) {
            return new TreeNode(nums[left]);
        }
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sortedArrayToBST(nums,left,mid);
        root.right = sortedArrayToBST(nums,mid+1,right);
        return root;
    }
}

//迭代: 左闭右闭 [left,right]
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums.length == 0) return null;
        
        TreeNode root = new TreeNode(-1);
        Queue<TreeNode> nodeQueue = new LinkedList<>();
        Queue<Integer> leftQueue = new LinkedList<>();
        Queue<Integer> rightQueue = new LinkedList<>();
        
        nodeQueue.offer(root);
        leftQueue.offer(0);
        rightQueue.offer(nums.length - 1);
        
        while (!nodeQueue.isEmpty()) {
            TreeNode currNode = nodeQueue.poll();
            int left = leftQueue.poll();
            int right = rightQueue.poll();
            int mid = left + ((right - left) >> 1);
            
            currNode.val = nums[mid];
            
            if (left <= mid -1) {
                currNode.left = new TreeNode(-1);
                nodeQueue.offer(currNode.left);
                leftQueue.offer(left);
                rightQueue.offer(mid - 1);
            }
            
            if (right >= mid + 1){
                currNode.right = new TreeNode(-1);
                nodeQueue.offer(currNode.right);
                leftQueue.offer(mid + 1);
                rightQueue.offer(right);
            }
        }
        return root;
    }
}
```

# 538.把二叉搜索树转换为累加树

[力扣题目链接](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。

```java
class Solution {
    public TreeNode convertBST(TreeNode root) {
        int sum = 0;
        if (root == null) return null;

        convertBST(root.right);

        sum += root.val;
        root.val = sum;
        convertBST(root.left);
        
        return root;

    }
}



```

